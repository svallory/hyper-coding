---
to: "{{ dir }}/{{ name }}.ts"
---
'use server'

/**
 * {{ pascalCase(name) }} Server Action
 *
 * Handles form submission with Zod validation and cache revalidation.
 * @if(revalidationType === 'path' || revalidationType === 'both')
 * Uses revalidatePath to invalidate cached data for specific routes.
 * @end
 * @if(revalidationType === 'tag' || revalidationType === 'both')
 * Uses revalidateTag to invalidate tagged cache entries across the app.
 * @end
 */

import { {{ camelCase(name) }}Schema, type {{ pascalCase(name) }}Input } from '@/{{ schemaDir }}/{{ kebabCase(name) }}'
@if(revalidationType === 'path' || revalidationType === 'both')
import { revalidatePath } from 'next/cache'
@end
@if(revalidationType === 'tag' || revalidationType === 'both')
import { revalidateTag } from 'next/cache'
@end
@if(redirectAfter && redirectPath)
import { redirect } from 'next/navigation'
@end

export type {{ pascalCase(name) }}State = {
  error?: string
  errors?: Record<string, string[]>
  success?: boolean
  data?: {{ pascalCase(name) }}Input
} | null

export async function {{ name }}(
  prevState: {{ pascalCase(name) }}State,
  formData: FormData
): Promise<{{ pascalCase(name) }}State> {
  try {
    // Extract and coerce form data
    const rawData = {
@each(field in fields)
@let(parts = field.split(':'))
@let(fieldName = parts[0])
@let(fieldType = parts[1] || 'string')
      {{ fieldName }}: @if(fieldType === 'number')
formData.get('{{ fieldName }}') ? Number(formData.get('{{ fieldName }}')) : undefined@elseif(fieldType === 'boolean')
formData.get('{{ fieldName }}') === 'true'@elseif(fieldType === 'date')
formData.get('{{ fieldName }}') ? new Date(formData.get('{{ fieldName }}') as string) : undefined@elseif(fieldType === 'array')
formData.getAll('{{ fieldName }}')@else
formData.get('{{ fieldName }}')@end
,
@endeach
    }

    // Validate with Zod schema
    const parsed = {{ camelCase(name) }}Schema.safeParse(rawData)

    if (!parsed.success) {
      const errors = parsed.error.flatten().fieldErrors
      return {
        error: 'Validation failed. Please check the form for errors.',
        errors,
      }
    }

    const data = parsed.data

    // TODO: Implement your business logic here
    console.log('{{ pascalCase(name) }} validated data:', data)

    // Example: Database mutation
    // await db.insert(table).values(data)

    // Example: API call
    // await fetch('/api/resource', {
    //   method: 'POST',
    //   body: JSON.stringify(data),
    // })

@if(revalidationType === 'path' || revalidationType === 'both')
    // Revalidate specific path(s)
    // This will refresh the cached data for the specified route
@if(revalidatePath)
    revalidatePath('{{ revalidatePath }}')
@else
    // Example: revalidatePath('/posts')
    // Example: revalidatePath('/dashboard')
    // Example: revalidatePath('/', 'layout') - revalidate entire layout
@end

@end
@if(revalidationType === 'tag' || revalidationType === 'both')
    // Revalidate by cache tag(s)
    // This will invalidate all cache entries with these tags
@if(revalidateTags && revalidateTags.length > 0)
@each(tag in revalidateTags)
    revalidateTag('{{ tag }}')
@endeach
@else
    // Example: revalidateTag('posts')
    // Example: revalidateTag('user-data')
    // Use tags in your fetch calls: fetch(url, { next: { tags: ['posts'] } })
@end

@end
@if(redirectAfter && redirectPath)
    // Redirect to success page
    redirect('{{ redirectPath }}')
@end

    return {
      success: true,
      data,
    }
  } catch (error) {
    console.error('{{ pascalCase(name) }} error:', error)
    return {
      error: error instanceof Error ? error.message : 'An unexpected error occurred',
    }
  }
}
