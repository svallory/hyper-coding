---
to: components/{{ model || pascalCase(name) }}Form.tsx
---
@{
  const helpers = require('../../../helpers')
  const { pascalCase, camelCase, titleCase } = helpers

  const modelName = model || pascalCase(name)
  const modelVar = camelCase(modelName)
  const features = helpers.detectProjectFeatures()

  // Parse schema to get fields
  let modelFields = []
  if (!fields && features.orm === 'prisma') {
    const models = helpers.parsePrismaSchema()
    const foundModel = models.find(m => m.name === modelName)
    if (foundModel) {
      modelFields = foundModel.fields.filter(f => !f.isId && !f.isCreatedAt && !f.isUpdatedAt)
    }
  } else if (fields) {
    modelFields = fields.split(',').map(f => {
      const [name, type] = f.trim().split(':')
      return { name, type: type || 'string', isRequired: true }
    })
  }

  // Helper to get form field component
  function getFormField(field) {
    const fieldName = field.name
    const fieldLabel = titleCase(fieldName)
    const isRequired = field.isRequired

    switch (field.type?.toLowerCase()) {
      case 'boolean':
        return `
              <FormField
                control={form.control}
                name="${fieldName}"
                render={({ field }) => (
                  <FormItem className="flex flex-row items-center justify-between rounded-lg border p-4">
                    <div className="space-y-0.5">
                      <FormLabel className="text-base">${fieldLabel}</FormLabel>
                    </div>
                    <FormControl>
                      <Switch
                        checked={field.value}
                        onCheckedChange={field.onChange}
                      />
                    </FormControl>
                  </FormItem>
                )}
              />`
      case 'text':
        return `
              <FormField
                control={form.control}
                name="${fieldName}"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>${fieldLabel}${isRequired ? ' *' : ''}</FormLabel>
                    <FormControl>
                      <Textarea {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />`
      case 'number':
      case 'int':
      case 'float':
        return `
              <FormField
                control={form.control}
                name="${fieldName}"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>${fieldLabel}${isRequired ? ' *' : ''}</FormLabel>
                    <FormControl>
                      <Input
                        type="number"
                        {...field}
                        onChange={(e) => field.onChange(Number(e.target.value))}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />`
      case 'date':
      case 'datetime':
        return `
              <FormField
                control={form.control}
                name="${fieldName}"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>${fieldLabel}${isRequired ? ' *' : ''}</FormLabel>
                    <FormControl>
                      <Input
                        type="datetime-local"
                        {...field}
                        value={field.value instanceof Date ? field.value.toISOString().slice(0, 16) : field.value}
                        onChange={(e) => field.onChange(new Date(e.target.value))}
                      />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />`
      default:
        return `
              <FormField
                control={form.control}
                name="${fieldName}"
                render={({ field }) => (
                  <FormItem>
                    <FormLabel>${fieldLabel}${isRequired ? ' *' : ''}</FormLabel>
                    <FormControl>
                      <Input {...field} />
                    </FormControl>
                    <FormMessage />
                  </FormItem>
                )}
              />`
    }
  }
}
'use client'

import { useRouter } from 'next/navigation'
import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { create{{ modelName }}, update{{ modelName }} } from '@/app/actions/{{ name }}'
import {
  {{ camelCase(modelName) }}Schema,
  type {{ modelName }},
} from '@/lib/schemas/{{ name }}-schema'
import { Button } from '@/components/ui/button'
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from '@/components/ui/form'
import { Input } from '@/components/ui/input'
import { Textarea } from '@/components/ui/textarea'
import { Switch } from '@/components/ui/switch'
import { useState } from 'react'
import { useToast } from '@/hooks/use-toast'

interface {{ modelName }}FormProps {
  initialData?: Partial<{{ modelName }}>
  id?: string
}

export function {{ modelName }}Form({ initialData, id }: {{ modelName }}FormProps) {
  const router = useRouter()
  const { toast } = useToast()
  const [isSubmitting, setIsSubmitting] = useState(false)

  const form = useForm<{{ modelName }}>({
    resolver: zodResolver({{ camelCase(modelName) }}Schema),
    defaultValues: initialData || {
@if(modelFields.length > 0)
@each(field in modelFields)
      {{ field.name }}: @if(field.type === 'boolean')false@else if(field.type === 'number' || field.type === 'int' || field.type === 'float')0@else if(field.type === 'date' || field.type === 'datetime')new Date()@else''@end,
@end
@else
      // TODO: Add default values for your fields
@end
    },
  })

  async function onSubmit(data: {{ modelName }}) {
    setIsSubmitting(true)

    try {
      if (id) {
        await update{{ modelName }}(id, data)
        toast({
          title: 'Success',
          description: '{{ modelName }} updated successfully',
        })
        router.push(`/{{ name }}/${id}`)
      } else {
        const result = await create{{ modelName }}(data)
        toast({
          title: 'Success',
          description: '{{ modelName }} created successfully',
        })
        router.push(`/{{ name }}/${result.id}`)
      }
      router.refresh()
    } catch (error) {
      toast({
        title: 'Error',
        description: error instanceof Error ? error.message : 'Something went wrong',
        variant: 'destructive',
      })
    } finally {
      setIsSubmitting(false)
    }
  }

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
        <div className="space-y-4">
@if(modelFields.length > 0)
@each(field in modelFields)
{{ getFormField(field) }}
@end
@else
          {/* TODO: Add form fields for your model */}
          <FormField
            control={form.control}
            name="name"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Name *</FormLabel>
                <FormControl>
                  <Input {...field} />
                </FormControl>
                <FormMessage />
              </FormItem>
            )}
          />
@end
        </div>

        <div className="flex gap-4">
          <Button type="submit" disabled={isSubmitting}>
            {isSubmitting ? 'Saving...' : id ? 'Update' : 'Create'}
          </Button>
          <Button
            type="button"
            variant="outline"
            onClick={() => router.back()}
            disabled={isSubmitting}
          >
            Cancel
          </Button>
        </div>
      </form>
    </Form>
  )
}
