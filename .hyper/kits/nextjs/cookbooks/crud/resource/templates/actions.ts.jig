---
to: app/actions/{{ name }}.ts
---
@{
  const helpers = require('../../../helpers')
  const { pascalCase, camelCase, pluralize } = helpers

  const modelName = model || pascalCase(name)
  const modelVar = camelCase(modelName)
  const pluralName = pluralize(name)
  const features = helpers.detectProjectFeatures()

  // Determine database client
  let dbImport = ''
  let dbClient = 'db'

  if (features.orm === 'prisma') {
    dbImport = "import { prisma } from '@/lib/prisma'"
    dbClient = 'prisma'
  } else if (features.orm === 'drizzle') {
    dbImport = "import { db } from '@/lib/db'"
    dbClient = 'db'
  }
}
'use server'

import { revalidatePath } from 'next/cache'
@if(dbImport)
{{ dbImport }}
@end
import {
  create{{ modelName }}Schema,
  update{{ modelName }}Schema,
  type Create{{ modelName }}Input,
  type Update{{ modelName }}Input,
} from '@/lib/schemas/{{ name }}-schema'

/**
 * Get all {{ pluralName }} with optional filtering and pagination
 */
export async function get{{ pluralize(modelName) }}(params?: {
  page?: number
  pageSize?: number
  sortBy?: string
  sortOrder?: 'asc' | 'desc'
  search?: string
}) {
  try {
    const { page = 1, pageSize = 10, sortBy = 'createdAt', sortOrder = 'desc', search } = params || {}
    const skip = (page - 1) * pageSize

@if(features.orm === 'prisma')
    // Build where clause for search
    const where = search
      ? {
          OR: [
            // Add searchable fields here
            // Example: { title: { contains: search, mode: 'insensitive' } },
          ],
        }
      : {}

    const [items, total] = await Promise.all([
      {{ dbClient }}.{{ modelVar }}.findMany({
        where,
        skip,
        take: pageSize,
        orderBy: { [sortBy]: sortOrder },
      }),
      {{ dbClient }}.{{ modelVar }}.count({ where }),
    ])

    return {
      items,
      total,
      page,
      pageSize,
      totalPages: Math.ceil(total / pageSize),
    }
@else if(features.orm === 'drizzle')
    // TODO: Implement Drizzle query
    // Example:
    // const items = await db.select().from({{ pluralName }}).limit(pageSize).offset(skip)
    // const [{ count }] = await db.select({ count: sql<number>`count(*)` }).from({{ pluralName }})

    return {
      items: [],
      total: 0,
      page,
      pageSize,
      totalPages: 0,
    }
@else
    // TODO: Implement database query
    throw new Error('Database not configured')
@end
  } catch (error) {
    console.error('Error fetching {{ pluralName }}:', error)
    throw new Error('Failed to fetch {{ pluralName }}')
  }
}

/**
 * Get a single {{ modelName }} by ID
 */
export async function get{{ modelName }}(id: string) {
  try {
@if(features.orm === 'prisma')
    const {{ modelVar }} = await {{ dbClient }}.{{ modelVar }}.findUnique({
      where: { id },
    })

    if (!{{ modelVar }}) {
      throw new Error('{{ modelName }} not found')
    }

    return {{ modelVar }}
@else if(features.orm === 'drizzle')
    // TODO: Implement Drizzle query
    // const [{{ modelVar }}] = await db.select().from({{ pluralName }}).where(eq({{ pluralName }}.id, id))
    throw new Error('Not implemented')
@else
    // TODO: Implement database query
    throw new Error('Database not configured')
@end
  } catch (error) {
    console.error('Error fetching {{ modelName }}:', error)
    throw new Error('Failed to fetch {{ modelName }}')
  }
}

/**
 * Create a new {{ modelName }}
 */
export async function create{{ modelName }}(data: Create{{ modelName }}Input) {
  try {
    // Validate input
    const validated = create{{ modelName }}Schema.parse(data)

@if(features.orm === 'prisma')
    const {{ modelVar }} = await {{ dbClient }}.{{ modelVar }}.create({
      data: validated,
    })

    revalidatePath('/{{ name }}')
    return {{ modelVar }}
@else if(features.orm === 'drizzle')
    // TODO: Implement Drizzle insert
    // const [{{ modelVar }}] = await db.insert({{ pluralName }}).values(validated).returning()
    revalidatePath('/{{ name }}')
    throw new Error('Not implemented')
@else
    // TODO: Implement database insert
    throw new Error('Database not configured')
@end
  } catch (error) {
    console.error('Error creating {{ modelName }}:', error)
    throw new Error('Failed to create {{ modelName }}')
  }
}

/**
 * Update a {{ modelName }}
 */
export async function update{{ modelName }}(id: string, data: Update{{ modelName }}Input) {
  try {
    // Validate input
    const validated = update{{ modelName }}Schema.parse(data)

@if(features.orm === 'prisma')
    const {{ modelVar }} = await {{ dbClient }}.{{ modelVar }}.update({
      where: { id },
      data: validated,
    })

    revalidatePath('/{{ name }}')
    revalidatePath(`/{{ name }}/${id}`)
    return {{ modelVar }}
@else if(features.orm === 'drizzle')
    // TODO: Implement Drizzle update
    // const [{{ modelVar }}] = await db.update({{ pluralName }}).set(validated).where(eq({{ pluralName }}.id, id)).returning()
    revalidatePath('/{{ name }}')
    revalidatePath(`/{{ name }}/${id}`)
    throw new Error('Not implemented')
@else
    // TODO: Implement database update
    throw new Error('Database not configured')
@end
  } catch (error) {
    console.error('Error updating {{ modelName }}:', error)
    throw new Error('Failed to update {{ modelName }}')
  }
}

/**
 * Delete a {{ modelName }}
 */
export async function delete{{ modelName }}(id: string) {
  try {
@if(features.orm === 'prisma')
    await {{ dbClient }}.{{ modelVar }}.delete({
      where: { id },
    })

    revalidatePath('/{{ name }}')
    return { success: true }
@else if(features.orm === 'drizzle')
    // TODO: Implement Drizzle delete
    // await db.delete({{ pluralName }}).where(eq({{ pluralName }}.id, id))
    revalidatePath('/{{ name }}')
    throw new Error('Not implemented')
@else
    // TODO: Implement database delete
    throw new Error('Database not configured')
@end
  } catch (error) {
    console.error('Error deleting {{ modelName }}:', error)
    throw new Error('Failed to delete {{ modelName }}')
  }
}
