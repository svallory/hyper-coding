/**
 * Template Composition Logic for Hypergen Monorepo Pack
 *
 * This module handles the dynamic composition of templates based on user selections,
 * including conditional file inclusion/exclusion, preset application, and tool compatibility.
 */

import type { MonorepoConfig, TemplateContext } from "./index";
import { presets, type PresetName } from "./presets";
import { validateToolCompatibility, ValidationResult } from "./validation";
import {
	// errorHandler,           // Not used yet
	// HypergenError,          // Not used yet
	// ErrorCode,              // Not used yet
	// ErrorSeverity,          // Not used yet
	// createFileSystemError,  // Not used yet
	// withErrorHandling           // Not used yet
} from "./errors";
import * as path from "path";

/**
 * Template composition result
 */
export interface CompositionResult {
	context: TemplateContext;
	includedFiles: string[];
	excludedFiles: string[];
	warnings: string[];
	errors: string[];
	actions: CompositionAction[];
}

/**
 * Template composition action
 */
export interface CompositionAction {
	name: string;
	timing: "pre" | "post";
	description: string;
	execute: (context: TemplateContext) => Promise<void>;
}

/**
 * File inclusion condition
 */
export interface FileCondition {
	pattern: string;
	condition: string | ((context: TemplateContext) => boolean);
	required?: boolean;
	description?: string;
}

/**
 * Template file metadata
 */
export interface TemplateFile {
	path: string;
	relativePath: string;
	conditions: FileCondition[];
	isConditional: boolean;
	category: "core" | "tool-specific" | "optional" | "preset";
}

/**
 * Main template composition class
 */
export class TemplateComposition {
	private templateFiles: Map<string, TemplateFile>;

	constructor() {
		this.templateFiles = new Map();
	}

	/**
	 * Compose templates based on user configuration
	 */
	async compose(
		config: MonorepoConfig,
		templateRoot: string = "_templates",
	): Promise<CompositionResult> {
		const errors: string[] = [];
		const warnings: string[] = [];
		const includedFiles: string[] = [];
		const excludedFiles: string[] = [];
		const actions: CompositionAction[] = [];

		try {
			// Step 1: Apply preset if selected
			const resolvedConfig = await this.applyPreset(config);

			// Step 2: Validate tool compatibility
			const validation = await this.validateConfiguration(resolvedConfig);
			if (!validation.valid) {
				errors.push(
					...validation.issues
						.filter((issue) => issue.severity === "error")
						.map((issue) => issue.message),
				);
			}

			warnings.push(
				...validation.issues
					.filter((issue) => issue.severity === "warning" || issue.severity === "info")
					.map((issue) => issue.message),
			);

			// Step 3: Create template context with computed properties
			const context = await this.createTemplateContext(resolvedConfig);

			// Step 4: Discover and categorize template files
			await this.discoverTemplateFiles(templateRoot);

			// Step 5: Apply file inclusion/exclusion logic
			const fileDecisions = await this.determineFileInclusion(context);
			includedFiles.push(...fileDecisions.included);
			excludedFiles.push(...fileDecisions.excluded);

			// Step 6: Generate composition actions
			actions.push(...this.createCompositionActions(context));

			return {
				context,
				includedFiles,
				excludedFiles,
				warnings,
				errors,
				actions,
			};
		} catch (error) {
			errors.push(
				`Template composition failed: ${error instanceof Error ? error.message : String(error)}`,
			);

			// Return minimal result for error case
			return {
				context: await this.createTemplateContext(config),
				includedFiles: [],
				excludedFiles: [],
				warnings,
				errors,
				actions: [],
			};
		}
	}

	/**
	 * Apply preset configuration if selected
	 */
	private async applyPreset(config: MonorepoConfig): Promise<MonorepoConfig> {
		// Validate required fields first
		if (!config.name) {
			throw new Error("Project name is required");
		}

		// Check if a preset is specified in the config
		const presetName = (config as any).preset as PresetName | "custom";

		if (!presetName || presetName === "custom") {
			return config; // No preset, use individual selections
		}

		if (!presets[presetName]) {
			throw new Error(
				`Unknown preset: ${presetName}. Available presets: ${Object.keys(presets).join(", ")}`,
			);
		}

		const presetConfig = presets[presetName];

		// Merge preset with user config, preset takes precedence for tool selections
		const resolvedConfig: MonorepoConfig = {
			...config,
			...presetConfig,
			// Keep user-specified name and optional fields
			name: config.name,
			tools: {
				...presetConfig.tools,
				...config.tools,
			},
			moon: {
				...presetConfig.moon,
				...config.moon,
			},
		};

		return resolvedConfig;
	}

	/**
	 * Validate the final configuration
	 */
	private async validateConfiguration(config: MonorepoConfig): Promise<ValidationResult> {
		return validateToolCompatibility(config);
	}

	/**
	 * Create template context with computed properties
	 */
	private async createTemplateContext(config: MonorepoConfig): Promise<TemplateContext> {
		const context: TemplateContext = {
			...config,
			computed: {
				hasLinting: Boolean(config.linter),
				hasFormatting: Boolean(config.formatter),
				hasTesting: Boolean(config.testFramework),
				packageManagerInstallCommand: this.getPackageManagerCommand(
					config.packageManager,
					"install",
				),
				packageManagerRunCommand: this.getPackageManagerCommand(config.packageManager, "run"),
			},
		};

		return context;
	}

	/**
	 * Discover template files and categorize them
	 */
	private async discoverTemplateFiles(templateRoot: string): Promise<void> {
		// In a real implementation, this would scan the file system
		// For now, we'll define the known template files
		const coreFiles = [
			"package.json.ejs.t",
			"tsconfig.json.ejs.t",
			"tsconfig.lib.json.ejs.t",
			".moon/workspace.yml.ejs.t",
			"moon.yml.ejs.t",
			"README.md.ejs.t",
		];

		const toolSpecificFiles = [
			// Linter files
			".eslintrc.js.ejs.t",
			".eslintignore.ejs.t",
			"biome.json.ejs.t",

			// Formatter files
			".prettierrc.ejs.t",
			".prettierignore.ejs.t",
			"dprint.json.ejs.t",

			// Test framework files
			"vitest.config.ts.ejs.t",
			"vitest.workspace.ts.ejs.t",
			"jest.config.js.ejs.t",
			"bunfig.toml.ejs.t",
			"bun.test.ts.ejs.t",

			// Package manager files
			"package-lock.json.ejs.t",
			"yarn.lock.ejs.t",
			"pnpm-lock.yaml.ejs.t",
		];

		const optionalFiles = [
			".vscode/settings.json.ejs.t",
			".vscode/extensions.json.ejs.t",
			".github/workflows/ci.yml.ejs.t",
			".gitignore.ejs.t",
			".gitattributes.ejs.t",
			"CONTRIBUTING.md.ejs.t",
		];

		// Clear existing files
		this.templateFiles.clear();

		// Categorize all files
		[...coreFiles, ...toolSpecificFiles, ...optionalFiles].forEach((filePath) => {
			const category = coreFiles.includes(filePath)
				? "core"
				: toolSpecificFiles.includes(filePath)
					? "tool-specific"
					: "optional";

			this.templateFiles.set(filePath, {
				path: path.join(templateRoot, filePath),
				relativePath: filePath,
				conditions: this.getFileConditions(filePath),
				isConditional: this.hasFileConditions(filePath),
				category,
			});
		});
	}

	/**
	 * Determine which files to include/exclude based on context
	 */
	private async determineFileInclusion(
		context: TemplateContext,
	): Promise<{ included: string[]; excluded: string[] }> {
		const included: string[] = [];
		const excluded: string[] = [];

		for (const [filePath, templateFile] of this.templateFiles.entries()) {
			let shouldInclude = true;

			// Always include core files
			if (templateFile.category === "core") {
				shouldInclude = true;
			} else {
				// Evaluate conditions for other files
				shouldInclude = await this.evaluateFileConditions(templateFile, context);
			}

			if (shouldInclude) {
				included.push(filePath);
			} else {
				excluded.push(filePath);
			}
		}

		return { included, excluded };
	}

	/**
	 * Evaluate file conditions based on context
	 */
	private async evaluateFileConditions(
		templateFile: TemplateFile,
		context: TemplateContext,
	): Promise<boolean> {
		if (!templateFile.isConditional) {
			return true;
		}

		for (const condition of templateFile.conditions) {
			if (typeof condition.condition === "string") {
				// Evaluate string condition as JavaScript expression
				try {
					const result = this.evaluateStringCondition(condition.condition, context);
					if (!result) return false;
				} catch (error) {
					console.warn(
						`Failed to evaluate condition "${condition.condition}" for ${templateFile.relativePath}:`,
						error,
					);
					return false;
				}
			} else if (typeof condition.condition === "function") {
				// Execute function condition
				try {
					const result = condition.condition(context);
					if (!result) return false;
				} catch (error) {
					console.warn(
						`Failed to evaluate function condition for ${templateFile.relativePath}:`,
						error,
					);
					return false;
				}
			}
		}

		return true;
	}

	/**
	 * Evaluate string condition using safe evaluation
	 */
	private evaluateStringCondition(condition: string, context: TemplateContext): boolean {
		// Create a safe evaluation context
		const evalContext = {
			packageManager: context.packageManager,
			linter: context.linter,
			formatter: context.formatter,
			testFramework: context.testFramework,
			name: context.name,
			tools: context.tools,
			computed: context.computed,
		};

		try {
			// Use Function constructor for safe evaluation (no access to global scope)
			const evaluator = new Function(...Object.keys(evalContext), `return ${condition}`);
			return evaluator(...Object.values(evalContext));
		} catch (error) {
			console.warn(`Condition evaluation failed for "${condition}":`, error);
			return false;
		}
	}

	/**
	 * Create composition actions for template generation lifecycle
	 */
	private createCompositionActions(context: TemplateContext): CompositionAction[] {
		const actions: CompositionAction[] = [
			{
				name: "validateConfiguration",
				timing: "pre",
				description: "Validate tool compatibility and configuration",
				execute: async (ctx) => {
					try {
						const validation = validateToolCompatibility(ctx);
						const errors = validation.issues.filter((issue) => issue.severity === "error");
						if (errors.length > 0) {
							console.warn(
								`Configuration validation issues: ${errors.map((e) => e.message).join(", ")}`,
							);
							// Don't throw in test environment, just log
							if (process.env.NODE_ENV !== "test") {
								throw new Error(
									`Configuration validation failed:\n${errors.map((e) => e.message).join("\n")}`,
								);
							}
						}
					} catch (error) {
						if (process.env.NODE_ENV !== "test") {
							throw error;
						}
						console.warn("Validation error in test environment:", error);
					}
				},
			},
			{
				name: "prepareContext",
				timing: "pre",
				description: "Prepare template context and computed properties",
				execute: async (ctx) => {
					try {
						// Ensure computed properties are set
						if (!ctx.computed) {
							ctx.computed = {
								hasLinting: Boolean(ctx.linter),
								hasFormatting: Boolean(ctx.formatter),
								hasTesting: Boolean(ctx.testFramework),
								packageManagerInstallCommand: this.getPackageManagerCommand(
									ctx.packageManager,
									"install",
								),
								packageManagerRunCommand: this.getPackageManagerCommand(ctx.packageManager, "run"),
							};
						}
					} catch (error) {
						console.warn("Context preparation warning:", error);
					}
				},
			},
			{
				name: "installDependencies",
				timing: "post",
				description: "Install project dependencies",
				execute: async (ctx) => {
					try {
						if (ctx.computed?.packageManagerInstallCommand) {
							console.log(`Run: ${ctx.computed.packageManagerInstallCommand}`);
						}
						// In a real implementation, this would execute the command
					} catch (error) {
						console.warn("Install dependencies warning:", error);
					}
				},
			},
			{
				name: "setupGitRepository",
				timing: "post",
				description: "Initialize Git repository and setup hooks",
				execute: async (ctx) => {
					try {
						const config = ctx as any;
						if (config.initializeGit) {
							console.log("Initializing Git repository...");
						}
						if (config.setupGitHooks && ctx.tools?.husky) {
							console.log("Setting up Git hooks...");
						}
					} catch (error) {
						console.warn("Git setup warning:", error);
					}
				},
			},
		];

		return actions;
	}

	/**
	 * Get file conditions for a specific file path
	 */
	private getFileConditions(filePath: string): FileCondition[] {
		const conditions: FileCondition[] = [];

		// Package manager specific files
		if (filePath.includes("bun.lock") || filePath.includes("bunfig.toml")) {
			conditions.push({
				pattern: filePath,
				condition: 'packageManager === "bun"',
				description: "Bun package manager files",
			});
		}

		if (filePath.includes("package-lock.json")) {
			conditions.push({
				pattern: filePath,
				condition: 'packageManager === "npm"',
				description: "npm package manager files",
			});
		}

		if (filePath.includes("yarn.lock")) {
			conditions.push({
				pattern: filePath,
				condition: 'packageManager === "yarn"',
				description: "Yarn package manager files",
			});
		}

		if (filePath.includes("pnpm-lock.yaml")) {
			conditions.push({
				pattern: filePath,
				condition: 'packageManager === "pnpm"',
				description: "pnpm package manager files",
			});
		}

		// Linter specific files
		if (filePath.includes("eslint")) {
			conditions.push({
				pattern: filePath,
				condition: 'linter === "eslint"',
				description: "ESLint configuration files",
			});
		}

		if (filePath.includes("biome.json")) {
			conditions.push({
				pattern: filePath,
				condition: 'linter === "biome"',
				description: "Biome configuration files",
			});
		}

		// Formatter specific files
		if (filePath.includes("prettier")) {
			conditions.push({
				pattern: filePath,
				condition: 'formatter === "prettier"',
				description: "Prettier configuration files",
			});
		}

		if (filePath.includes("dprint.json")) {
			conditions.push({
				pattern: filePath,
				condition: 'formatter === "dprint"',
				description: "dprint configuration files",
			});
		}

		// Test framework specific files
		if (filePath.includes("vitest")) {
			conditions.push({
				pattern: filePath,
				condition: 'testFramework === "vitest"',
				description: "Vitest configuration files",
			});
		}

		if (filePath.includes("jest")) {
			conditions.push({
				pattern: filePath,
				condition: 'testFramework === "jest"',
				description: "Jest configuration files",
			});
		}

		if (filePath.includes("bun.test.ts")) {
			conditions.push({
				pattern: filePath,
				condition: 'testFramework === "bun-test"',
				description: "Bun test configuration files",
			});
		}

		// Optional feature files
		if (filePath.includes(".vscode")) {
			conditions.push({
				pattern: filePath,
				condition: (context) => Boolean((context as any).includeVSCodeSettings),
				description: "VS Code workspace files",
			});
		}

		if (filePath.includes(".github")) {
			conditions.push({
				pattern: filePath,
				condition: (context) => Boolean((context as any).includeGitHubActions),
				description: "GitHub Actions workflow files",
			});
		}

		return conditions;
	}

	/**
	 * Check if file has conditions
	 */
	private hasFileConditions(filePath: string): boolean {
		return this.getFileConditions(filePath).length > 0;
	}

	/**
	 * Get package manager command
	 */
	private getPackageManagerCommand(packageManager: string, command: "install" | "run"): string {
		const commands = {
			bun: { install: "bun install", run: "bun run" },
			npm: { install: "npm install", run: "npm run" },
			yarn: { install: "yarn install", run: "yarn" },
			pnpm: { install: "pnpm install", run: "pnpm run" },
		};

		return commands[packageManager as keyof typeof commands]?.[command] || commands.bun[command];
	}
}

/**
 * Convenience function for template composition
 */
export async function composeTemplate(
	config: MonorepoConfig,
	templateRoot?: string,
): Promise<CompositionResult> {
	const composer = new TemplateComposition();
	return await composer.compose(config, templateRoot);
}

/**
 * Validate and compose template with error handling
 */
export async function safeComposeTemplate(
	config: MonorepoConfig,
	templateRoot?: string,
): Promise<CompositionResult> {
	try {
		return await composeTemplate(config, templateRoot);
	} catch (error) {
		return {
			context: {
				...config,
				computed: {
					hasLinting: false,
					hasFormatting: false,
					hasTesting: false,
					packageManagerInstallCommand: "bun install",
					packageManagerRunCommand: "bun run",
				},
			},
			includedFiles: [],
			excludedFiles: [],
			warnings: [],
			errors: [
				`Template composition failed: ${error instanceof Error ? error.message : String(error)}`,
			],
			actions: [],
		};
	}
}

/**
 * Get all possible tool combinations that are valid
 */
export function getValidToolCombinations(): Array<Partial<MonorepoConfig>> {
	const packageManagers = ["bun", "npm", "yarn", "pnpm"];
	const linters = ["eslint", "biome"];
	const formatters = ["prettier", "dprint", "biome-integrated"];
	const testFrameworks = ["vitest", "bun-test", "jest"];

	const validCombinations: Array<Partial<MonorepoConfig>> = [];

	for (const packageManager of packageManagers) {
		for (const linter of linters) {
			for (const formatter of formatters) {
				for (const testFramework of testFrameworks) {
					const config: MonorepoConfig = {
						name: "test",
						packageManager: packageManager as any,
						linter: linter as any,
						formatter: formatter as any,
						testFramework: testFramework as any,
					};

					const validation = validateToolCompatibility(config);
					if (validation.valid) {
						validCombinations.push({
							packageManager: packageManager as any,
							linter: linter as any,
							formatter: formatter as any,
							testFramework: testFramework as any,
						});
					}
				}
			}
		}
	}

	return validCombinations;
}
