# Recipe Engine DX Improvements — Open Items

Status: Planning / Discussion
Date: 2026-02-13
Branch: feat/mintlify-typedoc-integration

---

## 1. Auto-create directories for template `to:` paths

**Problem:** ~25 shell steps across the Next.js kit exist solely for `mkdir -p`. Every recipe has at least one.

**Examples:**
```yaml
# Current — boilerplate in every recipe
- name: Create route directory
  tool: shell
  command: mkdir -p app/{{ path }}

- name: Generate page
  tool: template
  template: templates/page.tsx.jig
```

**Proposed:** The template tool should auto-create parent directories for the `to:` path. No recipe changes needed — the shell steps just get deleted.

**Files to modify:** `src/recipe-engine/tools/template-tool.ts` — add `mkdirSync(dirname(outputPath), { recursive: true })` before writing.

**Impact:** ~25 shell steps eliminated across all kits.

---

## 2. Kit/Cookbook setup metadata (project context)

**Problem:** Recipes need project-level info (ORM, auth provider, UI library, etc.) but have no clean way to access it. Currently:
- Templates use `typeof detectProjectFeatures === 'function' ? detectProjectFeatures() : { orm: 'none' }` — but kit helpers are **never actually loaded** into the render context, so this always falls through to the default.
- Recipes shell out to `grep` package.json and export the result as a variable (~4 occurrences).
- The detection runs every time, is fragile, and results aren't shared across recipes.

**Proposed solution: Setup sections with committed metadata files**

### 2.1 Kit/Cookbook `setup` section

`kit.yml` or `cookbook.yml` can declare a `setup` section that defines metadata to collect:

```yaml
# kit.yml
setup:
  orm:
    type: enum
    values: [prisma, drizzle, none]
    detect: |
      if grep -q '"drizzle-orm"' package.json 2>/dev/null; then echo "drizzle"
      elif grep -q '"@prisma/client"' package.json 2>/dev/null; then echo "prisma"
      else echo "none"; fi
    prompt: "Which ORM does this project use?"

  auth:
    type: enum
    values: [nextauth, clerk, lucia, none]
    detect: |
      if grep -q '"next-auth"' package.json 2>/dev/null; then echo "nextauth"
      # ...
    prompt: "Which auth provider?"

  ui:
    type: enum
    values: [shadcn-radix, shadcn-baseui, none]
    detect: ...
    prompt: "Which UI library?"
```

### 2.2 Metadata file per kit/cookbook

Results are written to a well-known location, one file per kit (or cookbook):

```
.hypergen/
  kits/
    @kit/
      nextjs.yml          # kit-level setup results
      nextjs/
        domain.yml        # cookbook-level setup results (if cookbook has its own setup)
```

Contents:
```yaml
# .hypergen/kits/@kit/nextjs.yml
# Auto-generated by hypergen setup. Commit this file.
kit: "@kit/nextjs"
version: "1.0.0"
setupAt: "2026-02-13T10:30:00Z"
metadata:
  orm: drizzle
  auth: none
  ui: shadcn-baseui
```

### 2.3 When setup runs

- **First recipe execution** for a kit that has `setup` — if the metadata file is missing, run setup automatically.
- **`hypergen setup <kit>`** — explicit command to (re)run setup.
- **If all data is present** — setup is skipped entirely.
- **Staleness** — optionally re-detect on version mismatch (kit version in metadata vs installed kit version).

### 2.4 How recipes access it

A `project` (or `kit`) object is injected into both recipe `when:` conditions and template render contexts:

```yaml
# In recipe.yml when: conditions
when: "project.orm === 'drizzle'"

# In templates
@if(project.orm === 'drizzle')
```

### 2.5 Override protection

A kit/cookbook's setup can only write to its own namespace. The file path is derived from the kit/cookbook name, so:
- Kit `@kit/nextjs` → `.hypergen/kits/@kit/nextjs.yml`
- Cookbook `domain` within that kit → `.hypergen/kits/@kit/nextjs/domain.yml`

No kit can write to another kit's file. The engine enforces this by deriving the path from the kit identity, not from user input.

### 2.6 Open questions

- Should `detect` scripts run in the project root or the kit's working directory?
- Should setup results be mergeable (cookbook setup adds to kit setup) or isolated?
- How does `--ask=ai` interact with setup? Should AI be able to infer setup values from project description?
- Should there be a `teardown` section that cleans up when a kit is uninstalled?
- Naming: `project.orm` vs `kit.orm` vs `setup.orm`? The word "project" is overloaded.

---

## 3. Built-in `install` tool for dependency management

**Problem:** ~10 recipes have 10-20 lines of bash each for the same pattern: detect package manager → check if package exists → install if missing. The 4-way detection (bun/pnpm/yarn/npm) is copy-pasted everywhere.

**Examples (current):**
```yaml
- name: Check dependencies
  tool: shell
  command: |
    if ! bun pm ls zod &>/dev/null; then
      if command -v bun &> /dev/null; then
        bun add zod
      elif command -v pnpm &> /dev/null; then
        pnpm add zod
      elif command -v yarn &> /dev/null; then
        yarn add zod
      else
        npm install zod
      fi
    fi
```

**Proposed:**
```yaml
- name: Install dependencies
  tool: install
  packages: [zod, react-hook-form, "@hookform/resolvers"]
  dev: false          # optional, default false
  optional: true      # optional — don't fail if install fails
```

The engine uses the package manager from setup metadata (or auto-detects from lockfiles). The tool checks if packages are already installed before running.

**Note:** This is JS/Node-specific. For non-JS kits, the `shell` tool remains the escape hatch. Alternatively, this could be a kit-provided tool rather than a built-in.

**Files to create:** `src/recipe-engine/tools/install-tool.ts`
**Files to modify:** `src/recipe-engine/tools/index.ts` (register), tool registry

---

## 4. Recipe-level `onSuccess` message

**Problem:** Every recipe ends with a `tool: shell` step that's just `echo` statements. ~25 occurrences. Pure boilerplate.

**Examples (current):**
```yaml
- name: Success message
  tool: shell
  command: |
    echo "Entity '{{ name }}' generated successfully!"
    echo ""
    echo "Generated files:"
    echo "  lib/schemas/{{ name }}-schema.ts"
```

**Proposed:** A recipe-level `onSuccess` field rendered as Jig template:
```yaml
name: entity
# ...steps...

onSuccess: |
  Entity '{{ name }}' generated successfully!

  Generated files:
    lib/schemas/{{ name }}-schema.ts — Zod validation + types
  @if(detectedOrm === 'drizzle')
    db/schema/{{ name }}.ts — Drizzle table definition
  @end

  Next steps:
    1. Review the generated schema
    2. Run migrations
```

No `echo`, no `tool: shell`, just text. The engine renders it with the same Jig context as templates and prints it.

**Complement:** Could also add `onError` for failure messages.

**Files to modify:**
- Recipe parser (accept `onSuccess`/`onError` fields)
- Recipe engine (render and print after successful/failed execution)

---

## 5. Helpers loading — existing mechanism and gaps

### 5.1 What works today: `hypergen.config.js` helpers

The `HypergenConfig` interface (`src/config/hypergen-config.ts:56`) already supports:

```typescript
helpers?: string | Record<string, Function>
```

`HypergenConfigLoader.loadHelpers()` (`src/config/hypergen-config.ts:359-411`) handles loading:
- **String path** — resolves relative to project root, handles directories (looks for `index.js/mjs/cjs`), uses `import()` with `pathToFileURL()`
- **Object** — uses directly
- Returns `Record<string, Function>` that gets merged into the render context

These helpers flow through:
1. `hypergen-config.ts` → `loadHelpers()` loads them from the config file
2. `recipe-engine.ts:150` → `RecipeEngineConfig` has `helpers?: Record<string, any>`
3. `recipe-engine.ts:1135` → passes `helpers: this.config.helpers` to `context()`
4. `context.ts` → merges into `h` object: `{ ...builtinHelpers, ...configHelpers }`
5. `template-tool.ts:579+` → `buildRenderContext()` merges `builtinHelpers`, `mergedVars.h`, and `context.utils` into helpers, then spreads them into the render context at line 616

### 5.2 What's broken: kit/cookbook/recipe helpers

**`kit.yml`, `cookbook.yml`, and `recipe.yml` have NO helpers field.**

- `KitConfig` type (`src/config/types.ts:105-130`) — no `helpers` property
- `CookbookConfig` type (`src/config/types.ts:133-144`) — no `helpers` property
- `kit-parser.ts` `validateKitConfig()` — doesn't parse any helpers field
- `cookbook-parser.ts` — doesn't parse any helpers field

**This means:** `kits/nextjs/helpers/` is completely disconnected from the template render context. Every `typeof detectProjectFeatures === 'function'` guard in templates evaluates to `false` and falls through to defaults.

### 5.3 Phantom helpers (dead code)

Two helpers referenced in templates with `typeof` guards don't exist anywhere in the codebase:
- `parseFieldsString` — referenced but never defined
- `buildFieldDescriptions` — referenced but never defined

These always fail the `typeof` check. They were likely planned but never implemented.

`detectProjectFeatures` EXISTS in `kits/nextjs/helpers/detect-project.ts` but is never loaded into the render context due to the gap described above.

### 5.4 Proposed: extend `helpers` to kit.yml, cookbook.yml, recipe.yml

All three YAML configs should support the same `helpers` field as `hypergen.config.js`:

```yaml
# kit.yml
helpers: "./helpers/index.ts"

# cookbook.yml
helpers: "./local-helpers.ts"

# recipe.yml
helpers: "./recipe-helpers.ts"
```

**Merge order (outermost to innermost, later wins):**
1. `hypergen.config.js` helpers (project-level)
2. `kit.yml` helpers
3. `cookbook.yml` helpers
4. `recipe.yml` helpers

**Implementation:**
- Add `helpers?: string` to `KitConfig`, `CookbookConfig`, and recipe types in `src/config/types.ts`
- Kit-parser and cookbook-parser resolve the path relative to yaml file location, load via `import()`
- Recipe engine merges all helper layers before passing to `context()`
- Reuse the existing `loadHelpers()` logic from `HypergenConfigLoader` (extract to shared utility)

**Files to modify:**
- `src/config/types.ts` — add `helpers` field to `KitConfig`, `CookbookConfig`
- `src/config/kit-parser.ts` — parse and load helpers
- `src/config/cookbook-parser.ts` — parse and load helpers
- `src/recipe-engine/recipe-engine.ts` — merge kit → cookbook → recipe helpers into config
- `src/config/hypergen-config.ts` — extract `loadHelpers()` to a shared utility
- `kits/nextjs/kit.yml` — add `helpers: "./helpers/index.ts"`

### 5.5 TypeScript loading challenge

Kit helpers are TypeScript files. `loadHelpers()` currently only looks for `.js/.mjs/.cjs` index files. Loading `.ts` at runtime requires:
- **Bun** — handles `.ts` imports natively (no issue)
- **Node.js** — needs a loader (ts-node, tsx, jiti) or pre-compilation

**Pragmatic answer:** Hypergen targets bun. `import()` of `.ts` files works out of the box. If Node.js support is needed later, add jiti as a fallback. For now, just update `loadHelpers()` to also look for `index.ts` when scanning directories.

### 5.6 Relationship to setup metadata (#2)

If setup metadata lands (#2), `detectProjectFeatures()` becomes redundant — the ORM/auth/UI info lives in the committed metadata file. The helpers that remain useful are:
- String/parsing utilities (inflections, field parsing)
- Any future kit-specific helper functions

Both systems (#2 and #5) are complementary: setup metadata replaces detection, helpers loading enables utility functions.

---

## 7. Domain cookbook — completed but using workarounds

The domain cookbook (entity, value-object, enum, repository, service) was implemented in this session. It uses the shell-based ORM detection workaround and `mkdir -p` steps because the engine features above don't exist yet.

**When the above features land, the domain cookbook recipes should be updated to:**
- Remove all `mkdir -p` shell steps (#1)
- Remove ORM detection shell steps, use `project.orm` from setup metadata (#2)
- Remove success message shell steps, use `onSuccess` (#4)

**Entity `--withRepository` flag:** Implemented. When `true`, the entity recipe calls the repository recipe at the end, passing `name` through.

---

## 8. Sandbox script — current state

`sandbox/generate-todo-app.sh` was updated to:
- Add domain layer generation (Step 4) before CRUD UI (Step 5)
- Use `--withRepository` flag on entity calls to avoid separate repository calls
- Deduplicate CRUD calls (was generating same pages twice)
- 8 total steps (was 7, then 9, optimized to 8)

---

## Priority / Suggested order of implementation

1. **Auto-create directories** (#1) — Trivial change, huge impact, no API design needed
2. **Kit helpers loading** (#5) — Unblocks the helpers that already exist but don't work
3. **Setup metadata** (#2) — The big design piece. Replaces detection hacks with committed config
4. **onSuccess messages** (#4) — Simple parser/engine change, cleans up every recipe
5. **Install tool** (#3) — Nice to have, JS-specific, could be a kit-provided tool instead
6. **Update domain cookbook** (#7) — Once 1-4 land, simplify the recipes

---

## Files reference

### Engine files that would change
- `src/recipe-engine/tools/template-tool.ts` — auto-mkdir (#1), project context injection (#2)
- `src/recipe-engine/recipe-engine.ts` — setup metadata loading (#2), onSuccess rendering (#4), kit helpers merging (#5)
- `src/config/kit-parser.ts` — parse helpers field (#5), setup section (#2)
- `src/config/cookbook-parser.ts` — parse helpers field (#5), setup section (#2)
- `src/config/types.ts` — add `helpers` to KitConfig/CookbookConfig (#5), setup metadata types (#2)
- `src/config/hypergen-config.ts` — extract `loadHelpers()` to shared utility (#5)
- `src/recipe-engine/types.ts` — StepContext additions (project metadata) (#2)

### Kit files that would simplify
- All `kits/nextjs/cookbooks/*/recipe.yml` — remove mkdir/detect/echo steps
- `kits/nextjs/kit.yml` — add helpers + setup section
- `kits/nextjs/helpers/detect-project.ts` — becomes the `detect` script source for setup

---

## Continuation context

### What was completed in the previous session

1. **Domain cookbook fully implemented** — 16 files created under `kits/nextjs/cookbooks/domain/`:
   - `cookbook.yml`, entity/, value-object/, enum/, repository/, service/ (each with recipe.yml + templates)
   - All templates use `@ai` tags for AI-generated content
   - Entity recipe has `--withRepository` flag that calls repository sub-recipe

2. **Sandbox script updated** — `sandbox/generate-todo-app.sh` restructured to 8 steps:
   - Step 4: domain layer generation (entities with `--withRepository`, enums, value objects, services)
   - Step 5: CRUD UI (full crud for Todo/Organization, partial for Member)
   - Deduplicated from earlier version that had redundant CRUD calls

3. **Shell usage audit complete** — Categorized all ~65 `tool: shell` steps in the Next.js kit:
   - ~25 `mkdir -p` → solved by #1
   - ~4 ORM detection → solved by #2
   - ~10 dependency install → solved by #3
   - ~25 success messages → solved by #4
   - ~5 legitimate shell commands (remain as-is)

4. **Helpers chain fully traced** — See §5 above for the complete loading chain from hypergen.config.js through to template render context

### Test suite status

- **840+ tests pass, 0 fail** across 58 files (`bun test`)
- No engine changes were made — only kit YAML/template files created
- Domain cookbook correctness depends on engine features working correctly (recipe parser, template tool, step executor)

### Key architectural decisions made

- `detectProjectFeatures()` is a Next.js kit concern (not an engine concern) — JS-specific detection is fine
- Setup metadata files are per-kit, committed to repo (`.hypergen/kits/<kit-name>.yml`)
- Helpers use the same `string | Record<string, Function>` pattern at all levels
- Kit helpers are TypeScript — rely on bun's native `.ts` import for now
- `parseFieldsString` and `buildFieldDescriptions` are phantom helpers that need to be either implemented or removed from templates

### What to work on next

Pick from the priority list above. #1 (auto-mkdir) is a single line change. #5 (helpers loading) requires more plumbing but unblocks the existing helpers. #2 (setup metadata) is the biggest design piece.
