{
	"organization": {
		"zodSchema": "z.object({\n  name: z.string().min(1, \"Name is required\").max(255),\n  slug: z.string().min(1, \"Slug is required\").max(100).regex(/^[a-z0-9-]+$/, \"Slug must be lowercase with hyphens\"),\n  createdAt: z.coerce.date()\n})",
		"drizzleListQuery": "    const searchCondition = search\n      ? or(\n          like(organizations.name, `%${search}%`),\n          like(organizations.slug, `%${search}%`),\n        )\n      : undefined\n\n    const items = await db\n      .select()\n      .from(organizations)\n      .where(searchCondition)\n      .limit(pageSize)\n      .offset(skip)\n      .orderBy(sortOrder === 'desc' ? desc(organizations.createdAt) : asc(organizations.createdAt))\n\n    const [{ count: total }] = await db\n      .select({ count: sql<number>`count(*)` })\n      .from(organizations)\n      .where(searchCondition)\n\n    return {\n      items,\n      total,\n      page,\n      pageSize,\n      totalPages: Math.ceil(total / pageSize),\n    }",
		"drizzleMutations": "{\n  \"getById\": \"const [record] = await db.select().from(organizations).where(eq(organizations.id, id))\\n    if (!record) {\\n      throw new Error('Organization not found')\\n    }\\n    return record\",\n  \"create\": \"const [record] = await db.insert(organizations).values(validated).returning()\\n    revalidatePath('/organization')\\n    return record\",\n  \"update\": \"const [record] = await db.update(organizations).set(validated).where(eq(organizations.id, id)).returning()\\n    revalidatePath('/organization')\\n    revalidatePath(`/organization/${id}`)\\n    return record\",\n  \"delete\": \"await db.delete(organizations).where(eq(organizations.id, id))\\n    revalidatePath('/organization')\\n    return { success: true }\"\n}",
		"formFields": "          <FormField\n            control={form.control}\n            name=\"name\"\n            render={({ field }) => (\n              <FormItem>\n                <FormLabel>Name *</FormLabel>\n                <FormControl>\n                  <Input placeholder=\"Enter organization name\" {...field} />\n                </FormControl>\n                <FormMessage />\n              </FormItem>\n            )}\n          />\n          <FormField\n            control={form.control}\n            name=\"slug\"\n            render={({ field }) => (\n              <FormItem>\n                <FormLabel>Slug *</FormLabel>\n                <FormControl>\n                  <Input placeholder=\"my-organization\" {...field} />\n                </FormControl>\n                <FormMessage />\n              </FormItem>\n            )}\n          />\n          <FormField\n            control={form.control}\n            name=\"createdAt\"\n            render={({ field }) => (\n              <FormItem>\n                <FormLabel>Created At *</FormLabel>\n                <FormControl>\n                  <Input\n                    type=\"datetime-local\"\n                    {...field}\n                    value={field.value instanceof Date ? field.value.toISOString().slice(0, 16) : field.value}\n                    onChange={(e) => field.onChange(new Date(e.target.value))}\n                  />\n                </FormControl>\n                <FormMessage />\n              </FormItem>\n            )}\n          />"
	},
	"member": {
		"zodSchema": "z.object({\n  email: z.string().email(\"Invalid email address\"),\n  role: z.enum([\"admin\", \"member\", \"viewer\"], { required_error: \"Role is required\" }),\n  orgId: z.string().min(1, \"Organization is required\"),\n  joinedAt: z.coerce.date()\n})",
		"drizzleListQuery": "    const searchCondition = search\n      ? or(\n          like(members.email, `%${search}%`),\n          like(members.role, `%${search}%`),\n        )\n      : undefined\n\n    const items = await db\n      .select()\n      .from(members)\n      .where(searchCondition)\n      .limit(pageSize)\n      .offset(skip)\n      .orderBy(sortOrder === 'desc' ? desc(members.joinedAt) : asc(members.joinedAt))\n\n    const [{ count: total }] = await db\n      .select({ count: sql<number>`count(*)` })\n      .from(members)\n      .where(searchCondition)\n\n    return {\n      items,\n      total,\n      page,\n      pageSize,\n      totalPages: Math.ceil(total / pageSize),\n    }",
		"drizzleMutations": "{\n  \"getById\": \"const [record] = await db.select().from(members).where(eq(members.id, id))\\n    if (!record) {\\n      throw new Error('Member not found')\\n    }\\n    return record\",\n  \"create\": \"const [record] = await db.insert(members).values(validated).returning()\\n    revalidatePath('/member')\\n    return record\",\n  \"update\": \"const [record] = await db.update(members).set(validated).where(eq(members.id, id)).returning()\\n    revalidatePath('/member')\\n    revalidatePath(`/member/${id}`)\\n    return record\",\n  \"delete\": \"await db.delete(members).where(eq(members.id, id))\\n    revalidatePath('/member')\\n    return { success: true }\"\n}",
		"formFields": "          <FormField\n            control={form.control}\n            name=\"email\"\n            render={({ field }) => (\n              <FormItem>\n                <FormLabel>Email *</FormLabel>\n                <FormControl>\n                  <Input type=\"email\" placeholder=\"member@example.com\" {...field} />\n                </FormControl>\n                <FormMessage />\n              </FormItem>\n            )}\n          />\n          <FormField\n            control={form.control}\n            name=\"role\"\n            render={({ field }) => (\n              <FormItem>\n                <FormLabel>Role *</FormLabel>\n                <Select onValueChange={field.onChange} defaultValue={field.value}>\n                  <FormControl>\n                    <SelectTrigger>\n                      <SelectValue placeholder=\"Select a role\" />\n                    </SelectTrigger>\n                  </FormControl>\n                  <SelectContent>\n                    <SelectItem value=\"admin\">Admin</SelectItem>\n                    <SelectItem value=\"member\">Member</SelectItem>\n                    <SelectItem value=\"viewer\">Viewer</SelectItem>\n                  </SelectContent>\n                </Select>\n                <FormMessage />\n              </FormItem>\n            )}\n          />\n          <FormField\n            control={form.control}\n            name=\"orgId\"\n            render={({ field }) => (\n              <FormItem>\n                <FormLabel>Organization ID *</FormLabel>\n                <FormControl>\n                  <Input placeholder=\"Organization ID\" {...field} />\n                </FormControl>\n                <FormMessage />\n              </FormItem>\n            )}\n          />"
	},
	"todo": {
		"zodSchema": "z.object({\n  title: z.string().min(1, \"Title is required\").max(500),\n  description: z.string().optional(),\n  status: z.enum([\"pending\", \"in_progress\", \"done\", \"cancelled\"]).default(\"pending\"),\n  orgId: z.string().min(1, \"Organization is required\"),\n  assigneeId: z.string().optional(),\n  dueDate: z.coerce.date().optional()\n})",
		"drizzleListQuery": "    const searchCondition = search\n      ? or(\n          like(todos.title, `%${search}%`),\n          like(todos.description, `%${search}%`),\n        )\n      : undefined\n\n    const items = await db\n      .select()\n      .from(todos)\n      .where(searchCondition)\n      .limit(pageSize)\n      .offset(skip)\n      .orderBy(sortOrder === 'desc' ? desc(todos.dueDate) : asc(todos.dueDate))\n\n    const [{ count: total }] = await db\n      .select({ count: sql<number>`count(*)` })\n      .from(todos)\n      .where(searchCondition)\n\n    return {\n      items,\n      total,\n      page,\n      pageSize,\n      totalPages: Math.ceil(total / pageSize),\n    }",
		"drizzleMutations": "{\n  \"getById\": \"const [record] = await db.select().from(todos).where(eq(todos.id, id))\\n    if (!record) {\\n      throw new Error('Todo not found')\\n    }\\n    return record\",\n  \"create\": \"const [record] = await db.insert(todos).values(validated).returning()\\n    revalidatePath('/todo')\\n    return record\",\n  \"update\": \"const [record] = await db.update(todos).set(validated).where(eq(todos.id, id)).returning()\\n    revalidatePath('/todo')\\n    revalidatePath(`/todo/${id}`)\\n    return record\",\n  \"delete\": \"await db.delete(todos).where(eq(todos.id, id))\\n    revalidatePath('/todo')\\n    return { success: true }\"\n}",
		"formFields": "          <FormField\n            control={form.control}\n            name=\"title\"\n            render={({ field }) => (\n              <FormItem>\n                <FormLabel>Title *</FormLabel>\n                <FormControl>\n                  <Input placeholder=\"Enter todo title\" {...field} />\n                </FormControl>\n                <FormMessage />\n              </FormItem>\n            )}\n          />\n          <FormField\n            control={form.control}\n            name=\"description\"\n            render={({ field }) => (\n              <FormItem>\n                <FormLabel>Description</FormLabel>\n                <FormControl>\n                  <Textarea placeholder=\"Describe the task...\" {...field} />\n                </FormControl>\n                <FormMessage />\n              </FormItem>\n            )}\n          />\n          <FormField\n            control={form.control}\n            name=\"status\"\n            render={({ field }) => (\n              <FormItem>\n                <FormLabel>Status *</FormLabel>\n                <Select onValueChange={field.onChange} defaultValue={field.value}>\n                  <FormControl>\n                    <SelectTrigger>\n                      <SelectValue placeholder=\"Select status\" />\n                    </SelectTrigger>\n                  </FormControl>\n                  <SelectContent>\n                    <SelectItem value=\"pending\">Pending</SelectItem>\n                    <SelectItem value=\"in_progress\">In Progress</SelectItem>\n                    <SelectItem value=\"done\">Done</SelectItem>\n                    <SelectItem value=\"cancelled\">Cancelled</SelectItem>\n                  </SelectContent>\n                </Select>\n                <FormMessage />\n              </FormItem>\n            )}\n          />\n          <FormField\n            control={form.control}\n            name=\"dueDate\"\n            render={({ field }) => (\n              <FormItem>\n                <FormLabel>Due Date</FormLabel>\n                <FormControl>\n                  <Input\n                    type=\"datetime-local\"\n                    {...field}\n                    value={field.value instanceof Date ? field.value.toISOString().slice(0, 16) : field.value}\n                    onChange={(e) => field.onChange(new Date(e.target.value))}\n                  />\n                </FormControl>\n                <FormMessage />\n              </FormItem>\n            )}\n          />"
	}
}
