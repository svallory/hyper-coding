---
title: "Claude Code Hooks & Quality Control"
description: "Complete guide to implementing quality control gates using Claude Code hooks with peripheral awareness and intrusive thoughts for AI-driven development"
---

# Claude Code Hooks & Quality Control

This guide demonstrates how to implement comprehensive quality control gates using Claude Code hooks, combined with Git hooks, to create an intelligent development workflow with peripheral awareness.

## Available Hooks

### Claude Code Hooks
- **PreToolUse**: Runs before any tool execution (validation, permission checks)
- **PostToolUse**: Executes after successful tool completion
- **UserPromptSubmit**: Triggered when user submits a prompt
- **Notification**: Runs during specific notification events
- **Stop/SubagentStop**: Executes when agent/subagent finishes responding
- **SessionStart/SessionEnd**: Manages session initialization/cleanup
- **PreCompact**: Runs before context compaction

### Git Hooks
- **pre-commit**: Before commit is created
- **prepare-commit-msg**: Before commit message editor
- **commit-msg**: After commit message is written
- **post-commit**: After commit is completed
- **pre-push**: Before push to remote
- **post-receive**: After push is received (server-side)

## Quality Control Integration Flow

```mermaid
flowchart TD
    Start([Developer starts session]) --> SessionStart[1. SessionStart Hook]
    SessionStart --> InitDaemon[Initialize intrusive thoughts daemon]
    SessionStart --> SetupWatchers[Setup real-time linting watchers]
    
    InitDaemon --> UserPrompt[Developer gives prompt]
    SetupWatchers --> UserPrompt
    
    UserPrompt --> UserPromptSubmit[2. UserPromptSubmit Hook]
    UserPromptSubmit --> QuerySimilar[Query daemon for similar patterns]
    QuerySimilar --> HasSimilar{Similar patterns found?}
    HasSimilar -->|Yes| InjectContext[Inject intrusive thoughts]
    HasSimilar -->|No| PreToolUse
    InjectContext --> PreToolUse[3. PreToolUse Hook]
    
    PreToolUse --> ASTAnalysis[AST duplicate analysis]
    PreToolUse --> SyntaxCheck[Real-time syntax check]
    ASTAnalysis --> DuplicateFound{Duplicate detected?}
    SyntaxCheck --> SyntaxValid{Syntax valid?}
    
    DuplicateFound -->|Yes| WarnDuplicate[Warn about duplicate]
    DuplicateFound -->|No| WriteCode
    SyntaxValid -->|No| SyntaxError[Return syntax error]
    SyntaxValid -->|Yes| WriteCode[Claude writes code]
    WarnDuplicate --> WriteCode
    SyntaxError --> UserPrompt
    
    WriteCode --> PostToolUse[4. PostToolUse Hook]
    PostToolUse --> ImmediateLint[Immediate linting]
    PostToolUse --> FormatCheck[Format validation]
    ImmediateLint --> LintPassed{Lint passed?}
    FormatCheck --> FormatPassed{Format valid?}
    
    LintPassed -->|No| LintFeedback[Provide lint feedback]
    LintPassed -->|Yes| CodeComplete
    FormatPassed -->|No| FormatFeedback[Provide format feedback]
    FormatPassed -->|Yes| CodeComplete[Code writing complete]
    LintFeedback --> UserPrompt
    FormatFeedback --> UserPrompt
    
    CodeComplete --> CommitReady{Ready to commit?}
    CommitReady -->|Yes| PreCommit[5. pre-commit Hook]
    CommitReady -->|No| UserPrompt
    
    PreCommit --> PCFormat[Code formatting check]
    PreCommit --> PCLint[Comprehensive linting]
    PreCommit --> PCType[Type checking]
    PreCommit --> PCSecurity[Security scanning]
    PreCommit --> PCTest[Unit tests]
    
    PCFormat --> PCFormatPass{Format OK?}
    PCLint --> PCLintPass{Lint OK?}
    PCType --> PCTypePass{Types OK?}
    PCSecurity --> PCSecurityPass{Security OK?}
    PCTest --> PCTestPass{Tests pass?}
    
    PCFormatPass -->|No| FixFormat[Fix formatting issues]
    PCLintPass -->|No| FixLint[Fix lint issues]
    PCTypePass -->|No| FixTypes[Fix type errors]
    PCSecurityPass -->|No| FixSecurity[Fix security issues]
    PCTestPass -->|No| FixTests[Fix failing tests]
    
    FixFormat --> UserPrompt
    FixLint --> UserPrompt
    FixTypes --> UserPrompt
    FixSecurity --> UserPrompt
    FixTests --> UserPrompt
    
    PCFormatPass -->|Yes| AllPreCommitChecks
    PCLintPass -->|Yes| AllPreCommitChecks
    PCTypePass -->|Yes| AllPreCommitChecks
    PCSecurityPass -->|Yes| AllPreCommitChecks
    PCTestPass -->|Yes| AllPreCommitChecks{All pre-commit checks pass?}
    
    AllPreCommitChecks -->|No| PreCommitFail[Pre-commit failed]
    AllPreCommitChecks -->|Yes| PrepareCommitMsg[6. prepare-commit-msg Hook]
    PreCommitFail --> UserPrompt
    
    PrepareCommitMsg --> SuggestCommitFormat[Suggest conventional commit format]
    SuggestCommitFormat --> CommitMsg[7. commit-msg Hook]
    CommitMsg --> ValidateCommitMsg[Validate commit message format]
    ValidateCommitMsg --> CommitMsgValid{Message valid?}
    
    CommitMsgValid -->|No| FixCommitMsg[Fix commit message]
    CommitMsgValid -->|Yes| CreateCommit[Create commit]
    FixCommitMsg --> CommitMsg
    
    CreateCommit --> PostCommit[8. post-commit Hook]
    PostCommit --> UpdateMetrics[Update code metrics]
    PostCommit --> IndexPatterns[Index new patterns for future awareness]
    
    UpdateMetrics --> PushReady{Ready to push?}
    IndexPatterns --> PushReady
    PushReady -->|Yes| PrePush[9. pre-push Hook]
    PushReady -->|No| End
    
    PrePush --> FullBuild[Full build verification]
    PrePush --> IntegrationTests[Integration test suite]
    FullBuild --> BuildPass{Build successful?}
    IntegrationTests --> TestsPass{Integration tests pass?}
    
    BuildPass -->|No| FixBuild[Fix build issues]
    TestsPass -->|No| FixIntegrationTests[Fix integration tests]
    FixBuild --> UserPrompt
    FixIntegrationTests --> UserPrompt
    
    BuildPass -->|Yes| AllPrePushChecks
    TestsPass -->|Yes| AllPrePushChecks{All pre-push checks pass?}
    
    AllPrePushChecks -->|No| PrePushFail[Pre-push failed]
    AllPrePushChecks -->|Yes| PushChanges[Push to remote]
    PrePushFail --> UserPrompt
    
    PushChanges --> CI[10. CI/CD Pipeline]
    CI --> PerformanceTests[Performance tests]
    CI --> SecurityAudit[Security audit]
    CI --> DocsGeneration[Documentation generation]
    
    PerformanceTests --> PerfPass{Performance OK?}
    SecurityAudit --> SecAuditPass{Security audit OK?}
    DocsGeneration --> DocsPass{Docs generated?}
    
    PerfPass -->|No| PerfFail[Performance regression detected]
    SecAuditPass -->|No| SecFail[Security vulnerabilities found]
    DocsPass -->|No| DocsFail[Documentation generation failed]
    
    PerfFail --> CIFail[CI Pipeline failed]
    SecFail --> CIFail
    DocsFail --> CIFail
    
    PerfPass -->|Yes| CISuccess
    SecAuditPass -->|Yes| CISuccess
    DocsPass -->|Yes| CISuccess[CI Pipeline successful]
    
    CIFail --> End[Session continues with feedback]
    CISuccess --> SessionEnd[11. SessionEnd Hook]
    SessionEnd --> SavePatterns[Save learned patterns]
    SessionEnd --> ArchiveMetrics[Archive session metrics]
    SavePatterns --> End
    ArchiveMetrics --> End
    
    %% Semantic coloring - only differentiate by meaning, not shape
    classDef hookNode fill:#b3d9ff,stroke:#4d94ff,stroke-width:3px,color:#333333,font-weight:bold
    classDef qualityGate fill:#e6ccff,stroke:#b366ff,stroke-width:2px,color:#333333,font-weight:bold
    classDef decisionNode fill:#f8f8f8,stroke:#cccccc,stroke-width:2px,color:#333333,font-weight:bold
    classDef errorNode fill:#ffb3b3,stroke:#ff6666,stroke-width:2px,color:#333333,font-weight:bold
    classDef successNode fill:#b3ffb3,stroke:#66ff66,stroke-width:2px,color:#333333,font-weight:bold
    classDef actionNode fill:#b3e6ff,stroke:#33b3ff,stroke-width:2px,color:#333333,font-weight:bold
    
    class SessionStart,UserPromptSubmit,PreToolUse,PostToolUse,PreCommit,PrepareCommitMsg,CommitMsg,PostCommit,PrePush,SessionEnd hookNode
    class InitDaemon,SetupWatchers,QuerySimilar,ASTAnalysis,SyntaxCheck,ImmediateLint,FormatCheck,PCFormat,PCLint,PCType,PCSecurity,PCTest,UpdateMetrics,IndexPatterns,FullBuild,IntegrationTests,PerformanceTests,SecurityAudit,DocsGeneration qualityGate
    class HasSimilar,DuplicateFound,SyntaxValid,LintPassed,FormatPassed,CommitReady,PCFormatPass,PCLintPass,PCTypePass,PCSecurityPass,PCTestPass,AllPreCommitChecks,CommitMsgValid,PushReady,BuildPass,TestsPass,AllPrePushChecks,PerfPass,SecAuditPass,DocsPass decisionNode
    class SyntaxError,LintFeedback,FormatFeedback,FixFormat,FixLint,FixTypes,FixSecurity,FixTests,PreCommitFail,FixCommitMsg,FixBuild,FixIntegrationTests,PrePushFail,PerfFail,SecFail,DocsFail,CIFail errorNode
    class CodeComplete,CreateCommit,PushChanges,CISuccess,SavePatterns,ArchiveMetrics successNode
    class WriteCode,InjectContext,WarnDuplicate actionNode
```

## Hook Configuration Examples

### Claude Code Hooks Configuration

```json
{
  "hooks": {
    "SessionStart": [
      {
        "command": "./scripts/init-intrusive-thoughts.sh",
        "description": "Initialize background pattern daemon"
      }
    ],
    "PreToolUse": [
      {
        "matcher": "Write.*function|class|component",
        "command": "./scripts/check-duplicates.sh",
        "description": "Check for similar code patterns",
        "timeout": 2000
      },
      {
        "matcher": ".*",
        "command": "./scripts/syntax-check.sh",
        "description": "Real-time syntax validation"
      }
    ],
    "PostToolUse": [
      {
        "matcher": "Write|Edit",
        "command": "./scripts/immediate-lint.sh",
        "description": "Immediate linting feedback"
      }
    ],
    "UserPromptSubmit": [
      {
        "command": "./scripts/inject-context.sh",
        "description": "Add peripheral awareness context"
      }
    ]
  }
}
```

### Git Hooks Configuration

```bash
#!/usr/bin/env bash
# .git/hooks/pre-commit

set -e

echo "üîç Running pre-commit quality gates..."

# Format check
echo "üìù Checking code formatting..."
bun run format:check

# Linting
echo "üîç Running linters..."
bun run lint

# Type checking
echo "üîß Type checking..."
bun run typecheck

# Security scan
echo "üîí Security scanning..."
bun run security:scan

# Unit tests
echo "üß™ Running tests..."
bun run test

echo "‚úÖ All pre-commit checks passed!"
```

## Peripheral Awareness Implementation

### Background Daemon for Intrusive Thoughts

The intrusive thoughts system provides AI agents with human-like peripheral awareness by detecting similar patterns in the codebase.

#### Key Use Cases

1. **Utility Function Duplication**
   - Detection: AST analysis + semantic embeddings
   - Example: New `formatCurrency()` vs existing `formatMoney()`
   - Impact: High - prevents common duplications

2. **API Endpoint Patterns**
   - Detection: Route pattern analysis + HTTP method consistency
   - Example: New `POST /user-profile` vs existing `POST /users/profile`
   - Impact: Medium - improves API consistency

3. **Component Naming Consistency**
   - Detection: Edit distance + project convention learning
   - Example: New `user_card.tsx` in project using `UserCard.tsx` pattern
   - Impact: High - maintains design system consistency

4. **Dependency Management**
   - Detection: Functionality category matching
   - Example: Adding `moment` when `date-fns` already exists
   - Impact: Medium - prevents bundle bloat

#### Implementation Strategy

```bash
#!/usr/bin/env bash
# scripts/inject-context.sh

# Query background daemon for similar patterns
SIMILAR_PATTERNS=$(curl -s "http://localhost:8080/api/similar" \
  -H "Content-Type: application/json" \
  -d "{\"action\": \"$CLAUDE_TOOL_NAME\", \"content\": \"$CLAUDE_TOOL_ARGS\"}")

if [ -n "$SIMILAR_PATTERNS" ]; then
  echo "üí≠ Intrusive thought: $SIMILAR_PATTERNS"
  export CLAUDE_CONTEXT_INJECTION="$SIMILAR_PATTERNS"
fi
```

### Similarity Detection Methods

- **Function signatures**: AST analysis + purpose embeddings
- **Naming patterns**: Edit distance + convention learning
- **Dependencies**: Functionality overlap analysis
- **Architecture patterns**: Structure similarity matching

### Threshold Management

- Start conservative (high similarity threshold)
- Learn from developer feedback (accept/dismiss)
- Different thresholds for different code types
- Configurable per project/team

## Quality Control Gate Timing

### Real-Time Gates (Claude Hooks)
- **PreToolUse**: Syntax validation, similarity detection, security checks
- **PostToolUse**: Immediate linting, formatting, basic type checking
- **UserPromptSubmit**: Inject peripheral awareness context before decision-making

### Commit Gates (Git Hooks)
- **pre-commit**: Comprehensive linting, formatting, type checking, security scans
- **commit-msg**: Conventional commit format validation
- **post-commit**: Metrics updates, pattern indexing for future intrusive thoughts

### Push Gates (Git Hooks)
- **pre-push**: Full build verification, integration tests

### Continuous Integration Gates
- **Performance tests**: Automated performance regression detection
- **Security audit**: Deep security analysis
- **Documentation generation**: Automated API docs and guides

## Benefits of Integrated Quality Control

1. **Immediate Feedback**: Real-time quality checks during development
2. **Pattern Recognition**: AI learns project-specific conventions
3. **Duplication Prevention**: Automatic detection of similar code patterns
4. **Consistency Enforcement**: Maintains coding standards across the team
5. **Security First**: Multiple layers of security validation
6. **Performance Optimization**: Prevents performance regressions

## Best Practices

### Hook Performance
- Keep hooks under 2 seconds for real-time feedback
- Use background daemons for expensive operations
- Cache similarity analysis results
- Implement progressive timeout strategies

### Context Management
- Balance intrusive thoughts with noise reduction
- Learn from developer accept/dismiss feedback
- Adapt thresholds based on project complexity
- Maintain context relevance scoring

### Team Adoption
- Start with conservative similarity thresholds
- Gradually increase sensitivity based on team feedback
- Provide easy override mechanisms for false positives
- Monitor and report quality improvement metrics

## Future Enhancements

### ML Pattern Recognition
- Learn project-specific patterns over time
- Identify team coding preferences
- Suggest architectural improvements

### Team Knowledge Sharing
- Cross-developer pattern sharing
- Cross-project similarity detection
- Knowledge preservation when developers leave

### Predictive Assistance
- "You usually add error handling to network calls"
- "This pattern typically needs unit tests"
- "Similar components usually have loading states"

This integrated approach creates a comprehensive quality control system that provides immediate feedback while building institutional knowledge through AI-powered pattern recognition.

## Complete Scenario: Adding User Profile Analytics

This realistic scenario demonstrates every HyperDev feature and hook activation, including reactive context changing the agent's behavior.

### Initial Request
**User**: "Add a user analytics dashboard to track profile engagement metrics - page views, time spent, and interaction patterns. It should integrate with our existing user system."

### Hook Activation Flow

#### 1. SessionStart Hook ‚Üí Initialize System
```bash
# SessionStart hook activates
./scripts/init-intrusive-thoughts.sh
# - Starts background daemon indexing existing codebase
# - Indexes: UserProfile.tsx, UserService.ts, analytics.utils.ts
# - Sets up real-time linting watchers
```

#### 2. UserPromptSubmit Hook ‚Üí Peripheral Awareness
```bash
# UserPromptSubmit hook queries daemon
curl -s "http://localhost:8080/api/similar" -d '{
  "action": "create_feature", 
  "content": "user analytics dashboard profile engagement metrics"
}'

# Daemon response:
{
  "intrusive_thoughts": [
    "üîç Found existing AnalyticsService.ts in services/analytics/",
    "üìä UserProfile.tsx already tracks basic metrics",
    "‚ö†Ô∏è analytics.utils.ts has formatMetrics() function",
    "üéØ Similar dashboard pattern in AdminDashboard.tsx"
  ]
}
```

#### 3. PreToolUse Hook ‚Üí Reactive Context Changes Agent Plan

**Original Agent Plan**: Create new analytics system from scratch

**After Intrusive Thoughts**: 
```
üí≠ PERIPHERAL AWARENESS INJECTION:
- "Similar function formatMetrics() exists in analytics.utils.ts"
- "UserProfile.tsx already has engagement tracking hooks"
- "AdminDashboard.tsx shows established dashboard patterns"
- "AnalyticsService.ts has data collection infrastructure"
```

**Agent's Revised Plan**: "I see there's already analytics infrastructure! Let me extend the existing system instead of creating duplicate code."

#### 4. PreToolUse Hook ‚Üí Quality Gates
```bash
# Syntax validation
./scripts/syntax-check.sh
# AST analysis detects agent is about to reuse existing patterns
./scripts/check-duplicates.sh
# Security check passes
./scripts/security-scan.sh
```

#### 5. Code Generation with Awareness

**Agent writes**:
```typescript
// types/analytics.ts
import { BaseMetrics } from './analytics.utils'; // üí≠ Reusing existing types

export interface ProfileEngagementMetrics extends BaseMetrics {
  pageViews: number;
  timeSpent: number;
  interactionEvents: ClickEvent[];
}
```

#### 6. PostToolUse Hook ‚Üí Immediate Feedback
```bash
# Immediate linting
eslint types/analytics.ts
# ‚úÖ No issues found

# Format check  
prettier --check types/analytics.ts
# ‚úÖ Formatting correct
```

#### 7. Another PreToolUse ‚Üí More Intrusive Thoughts

**Agent about to create**: `ProfileAnalyticsService.ts`

**Daemon injection**: 
```
üí≠ "AnalyticsService.ts already exists with data collection methods"
üí≠ "Consider extending existing service instead of creating new one"
```

**Agent pivots**: "I'll extend the existing AnalyticsService instead!"

```typescript
// services/analytics/AnalyticsService.ts
export class AnalyticsService {
  // ... existing methods

  // üí≠ Adding to existing service based on intrusive thoughts
  async trackProfileEngagement(userId: string, metrics: ProfileEngagementMetrics) {
    return this.collectMetrics('profile_engagement', { userId, ...metrics });
  }
}
```

#### 8. Component Creation with Pattern Recognition

**Agent about to create**: `user_analytics_dashboard.tsx`

**Daemon injection**:
```
üí≠ "Project uses PascalCase: UserProfile.tsx, AdminDashboard.tsx"
üí≠ "Dashboard components are in components/dashboards/"
```

**Agent adjusts**: Creates `components/dashboards/UserAnalyticsDashboard.tsx` instead

```typescript
// components/dashboards/UserAnalyticsDashboard.tsx
import React from 'react';
import { useAnalytics } from '../hooks/useAnalytics'; // üí≠ Reusing existing hook
import { MetricsCard } from '../ui/MetricsCard'; // üí≠ Reusing existing component
import { formatMetrics } from '../../utils/analytics.utils'; // üí≠ Found by daemon

export const UserAnalyticsDashboard: React.FC<{userId: string}> = ({ userId }) => {
  const { metrics, loading } = useAnalytics(userId);
  
  return (
    <div className="analytics-dashboard">
      <MetricsCard 
        title="Profile Engagement"
        data={formatMetrics(metrics.profileEngagement)} 
      />
    </div>
  );
};
```

#### 9. Pre-commit Hook ‚Üí Comprehensive Quality Gates

```bash
# 5. pre-commit Hook activates
git add .

# Format check
prettier --write .
# ‚úÖ All files formatted

# Comprehensive linting  
eslint . --fix
# ‚úÖ No linting errors

# Type checking
tsc --noEmit
# ‚úÖ No type errors

# Security scan
npm audit
# ‚úÖ No vulnerabilities

# Unit tests
npm test
# ‚úÖ All tests pass (including new analytics tests)
```

#### 10. Commit Message Generation

```bash
# 6. prepare-commit-msg Hook
./scripts/suggest-commit-format.sh

# Suggests: "feat(analytics): add user profile engagement dashboard"

# 7. commit-msg Hook validates format
./scripts/validate-commit-msg.sh
# ‚úÖ Follows conventional commits
```

#### 11. Post-commit Pattern Learning

```bash
# 8. post-commit Hook
git commit -m "feat(analytics): add user profile engagement dashboard

- Extend existing AnalyticsService with profile tracking
- Reuse MetricsCard and formatMetrics utilities  
- Follow established dashboard patterns
- Add TypeScript interfaces for type safety"

# Update metrics
./scripts/update-metrics.sh
# Logs: +1 feature extension, +0 duplications, +1 pattern reuse

# Index new patterns
./scripts/index-patterns.sh
# Learns: "UserAnalyticsDashboard follows naming convention"
# Learns: "Analytics features extend AnalyticsService"
```

#### 12. Pre-push Integration Tests

```bash
# 9. pre-push Hook
git push origin feature/user-analytics

# Full build verification
npm run build
# ‚úÖ Build successful

# Integration tests
npm run test:integration  
# ‚úÖ Analytics integration tests pass
```

#### 13. CI/CD Pipeline

```bash
# 10. CI Pipeline triggers
# Performance tests
npm run test:performance
# ‚úÖ No performance regressions

# Security audit  
npm run security:audit
# ‚úÖ No new vulnerabilities

# Documentation generation
npm run docs:generate
# ‚úÖ TypeScript API docs updated
```

#### 14. SessionEnd ‚Üí Knowledge Preservation

```bash
# 11. SessionEnd Hook
./scripts/save-patterns.sh
# Saves learned patterns:
# - "Analytics features extend existing services"
# - "Dashboard components use MetricsCard pattern"  
# - "formatMetrics utility is reusable"

./scripts/archive-metrics.sh
# Session stats: 85% code reuse, 0 duplications, 3 intrusive thoughts acted upon
```

### Key Reactive Context Impacts

1. **Prevented Duplication**: Agent was going to create new analytics service, daemon suggested extending existing one
2. **Enforced Naming Conventions**: `user_analytics_dashboard.tsx` ‚Üí `UserAnalyticsDashboard.tsx`
3. **Promoted Reuse**: Found and reused `formatMetrics()`, `MetricsCard`, `useAnalytics` hook
4. **Pattern Recognition**: Followed established dashboard component structure

### Metrics Comparison

**Without Intrusive Thoughts**:
- New files: 8
- Lines of code: 450
- Duplicate functions: 3
- Convention violations: 2

**With Intrusive Thoughts**:
- New files: 3 (extended existing)
- Lines of code: 180
- Duplicate functions: 0
- Convention violations: 0
- Pattern reuse: 5 instances

### Learning Loop

The daemon learned from this session:
1. **Analytics Pattern**: Extensions go in `AnalyticsService`
2. **Dashboard Pattern**: Use `MetricsCard` + `useAnalytics`
3. **Naming Pattern**: User features use `UserXxxDashboard` format
4. **File Organization**: Dashboards go in `components/dashboards/`

These patterns will inform future intrusive thoughts, creating a continuous improvement cycle where the AI becomes increasingly aligned with project conventions and patterns.