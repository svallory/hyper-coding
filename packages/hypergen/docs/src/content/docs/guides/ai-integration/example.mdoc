---
title: "Complete Example: CRUD Edit Page"
description: End-to-end walkthrough of a recipe that uses AI blocks to generate a smart edit page
time: 12 minutes
prerequisites: Understanding of the 2-pass overview, Jig tags, and recipe basics
---

# Complete Example: CRUD Edit Page

**What you'll learn**: How to build a recipe that combines deterministic scaffolding with AI-generated code
**Time needed**: 12 minutes
**Prerequisites**: [2-pass overview](/guides/ai-integration/overview), [Jig tags](/guides/ai-integration/jig-tags), [recipe basics](/tutorials/running-recipes)

## The Goal

Build a recipe that generates a CRUD edit page for any model. The template handles the boilerplate (imports, component structure, form layout), while AI decides:

- Which fields to show on the form
- What validation rules to apply
- How to name the database migration

## Project Structure

```
my-cookbook/crud/edit-page/
├── recipe.yml
└── templates/
    ├── edit-page.jig
    └── migration.jig
```

## Recipe Configuration

```yaml
# recipe.yml
name: edit-page
description: Generate a CRUD edit page with AI-assisted field selection

variables:
  model:
    type: string
    required: true
    pattern: ^[A-Z][a-zA-Z0-9]*$
    description: Model name in PascalCase
    prompt: "Model name?"

  fields:
    type: string
    required: true
    description: JSON array of model field objects
    prompt: "Model fields (JSON)?"

  database:
    type: string
    default: postgresql
    description: Database type
```

## Template 1: The Edit Page

```jig
---
to: "src/pages/{{ model }}Edit.tsx"
---
{{-- Global context shared with all AI blocks --}}
@context()
  Project stack: React, TypeScript, Zod for validation.
  Database: {{ database }}.
  Style: functional components with hooks.
@end

import React, { useEffect, useState } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import { z } from 'zod';
import { useForm } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { api } from '../lib/api';

@ai()
  @context()
    The {{ model }} model has these fields:
    {{ fields }}

    Generate a Zod schema for form validation.
    Include appropriate validators for each field type.
    Skip auto-generated fields (id, createdAt, updatedAt).
  @end

  @prompt()
    Create a Zod validation schema for editing a {{ model }}.
    Export it as `const {{ camelCase(model) }}Schema = z.object({ ... })`.
    Also export the inferred type as `type {{ model }}FormData`.
  @end

  @output({ key: 'validationSchema' })
    const {{ camelCase(model) }}Schema = z.object({
      name: z.string().min(1, 'Required'),
      email: z.string().email('Invalid email'),
    });
    type {{ model }}FormData = z.infer<typeof {{ camelCase(model) }}Schema>;
  @end
@end

export const {{ model }}Edit: React.FC = () => {
  const { id } = useParams<{ id: string }>();
  const navigate = useNavigate();
  const [loading, setLoading] = useState(true);

  const {
    register,
    handleSubmit,
    reset,
    formState: { errors, isSubmitting },
  } = useForm<{{ model }}FormData>({
    resolver: zodResolver({{ camelCase(model) }}Schema),
  });

  useEffect(() => {
    if (id) {
      api.get(`/{{ kebabCase(model) }}s/${id}`).then((data) => {
        reset(data);
        setLoading(false);
      });
    }
  }, [id, reset]);

  const onSubmit = async (data: {{ model }}FormData) => {
    await api.put(`/{{ kebabCase(model) }}s/${id}`, data);
    navigate(`/{{ kebabCase(model) }}s/${id}`);
  };

  if (loading) return <div>Loading...</div>;

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <h1>Edit {{ model }}</h1>

      @ai()
        @context()
          The {{ model }} model fields: {{ fields }}

          Use react-hook-form's `register` function.
          Show validation errors from `errors` object.
          Use semantic HTML with labels.
        @end

        @prompt()
          Generate the form fields JSX for editing a {{ model }}.
          Each field should have a label, input with `{...register('fieldName')}`,
          and an error message display.
          Skip id, createdAt, updatedAt.
        @end

        @output({ key: 'formFields' })
          <div>
            <label htmlFor="name">Name</label>
            <input id="name" {...register('name')} />
            {errors.name && <span>{errors.name.message}</span>}
          </div>
        @end
      @end

      <button type="submit" disabled={isSubmitting}>
        {isSubmitting ? 'Saving...' : 'Save'}
      </button>
    </form>
  );
};
```

## Template 2: The Migration

```jig
---
to: "migrations/{{ snakeCase(model) }}_add_edit_fields.sql"
---
@ai()
  @context()
    Database: {{ database }}.
    Model: {{ model }}.
    Table: {{ snakeCase(model) }}s.
    Fields: {{ fields }}
  @end

  @prompt()
    Generate a database migration that ensures all editable fields
    from the {{ model }} model exist in the {{ snakeCase(model) }}s table.
    Use ALTER TABLE ADD COLUMN IF NOT EXISTS syntax.
    Include appropriate column types and constraints.
  @end

  @output({ key: 'migrationSQL' })
    ALTER TABLE {{ snakeCase(model) }}s
      ADD COLUMN IF NOT EXISTS name TEXT NOT NULL,
      ADD COLUMN IF NOT EXISTS email TEXT NOT NULL;
  @end
@end
```

## Running It

### Step 1: Pass 1 — Collect Prompts

```bash
hypergen run crud/edit-page \
  --model=Organization \
  --fields='[{"name":"id","type":"uuid"},{"name":"name","type":"string"},{"name":"domain","type":"string"},{"name":"plan","type":"enum","values":["free","pro","enterprise"]},{"name":"maxSeats","type":"integer"},{"name":"createdAt","type":"datetime"}]' \
  --database=postgresql
```

Hypergen renders both templates, collects the three AI blocks (`validationSchema`, `formFields`, `migrationSQL`), and prints the prompt document. Exit code: `2`.

### Step 2: Get Answers

Save the prompt and feed it to your AI tool of choice, or write the answers manually:

```json
{
  "validationSchema": "const organizationSchema = z.object({\n  name: z.string().min(1, 'Organization name is required'),\n  domain: z.string().url('Must be a valid domain').optional(),\n  plan: z.enum(['free', 'pro', 'enterprise']),\n  maxSeats: z.number().int().min(1, 'Must have at least 1 seat'),\n});\ntype OrganizationFormData = z.infer<typeof organizationSchema>;",

  "formFields": "<div>\n  <label htmlFor=\"name\">Organization Name</label>\n  <input id=\"name\" {...register('name')} />\n  {errors.name && <span className=\"error\">{errors.name.message}</span>}\n</div>\n<div>\n  <label htmlFor=\"domain\">Domain</label>\n  <input id=\"domain\" type=\"url\" {...register('domain')} />\n  {errors.domain && <span className=\"error\">{errors.domain.message}</span>}\n</div>\n<div>\n  <label htmlFor=\"plan\">Plan</label>\n  <select id=\"plan\" {...register('plan')}>\n    <option value=\"free\">Free</option>\n    <option value=\"pro\">Pro</option>\n    <option value=\"enterprise\">Enterprise</option>\n  </select>\n  {errors.plan && <span className=\"error\">{errors.plan.message}</span>}\n</div>\n<div>\n  <label htmlFor=\"maxSeats\">Max Seats</label>\n  <input id=\"maxSeats\" type=\"number\" {...register('maxSeats', { valueAsNumber: true })} />\n  {errors.maxSeats && <span className=\"error\">{errors.maxSeats.message}</span>}\n</div>",

  "migrationSQL": "ALTER TABLE organizations\n  ADD COLUMN IF NOT EXISTS name TEXT NOT NULL,\n  ADD COLUMN IF NOT EXISTS domain TEXT,\n  ADD COLUMN IF NOT EXISTS plan TEXT NOT NULL DEFAULT 'free' CHECK (plan IN ('free', 'pro', 'enterprise')),\n  ADD COLUMN IF NOT EXISTS max_seats INTEGER NOT NULL DEFAULT 1 CHECK (max_seats >= 1);"
}
```

### Step 3: Pass 2 — Generate Files

```bash
hypergen run crud/edit-page \
  --model=Organization \
  --fields='[...]' \
  --database=postgresql \
  --answers ./ai-answers.json
```

Hypergen generates:
- `src/pages/OrganizationEdit.tsx` — complete React component with AI-generated validation and form fields
- `migrations/organization_add_edit_fields.sql` — AI-generated migration

## Key Takeaways

1. **Structure stays deterministic**: File paths, imports, component skeleton, hooks setup — all controlled by the template author
2. **Judgment is delegated**: Field selection, validation rules, SQL types — these vary by model and benefit from intelligence
3. **Context flows naturally**: Jig variables (`{{ model }}`, `{{ fields }}`) render inside `@context` and `@prompt`, giving the AI model-specific information
4. **Answers are reviewable**: The JSON file is plain text — review, edit, or regenerate any answer before Pass 2
5. **Format hints guide quality**: The `@output` body shows the AI exactly what shape the answer should take
