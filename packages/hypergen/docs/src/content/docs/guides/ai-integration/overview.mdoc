---
title: AI-Assisted Code Generation
description: How Hypergen combines deterministic templates with AI to generate intelligent, context-aware code
time: 10 minutes
prerequisites: Understanding of Hypergen templates and recipes
---

# AI-Assisted Code Generation

**What you'll learn**: How Hypergen's 2-pass generation system lets you combine deterministic templates with AI-generated code
**Time needed**: 10 minutes
**Prerequisites**: Familiarity with [templates](/tutorials/creating-templates) and [recipes](/tutorials/running-recipes)

## The Problem

Templates are great for generating boilerplate with predictable structure. But some code decisions require judgment — which fields to show on a card, how to name a migration, what validation rules to apply. These are decisions that benefit from intelligence, not just interpolation.

## The Scaffold+Complete Approach

Hypergen solves this with a **Scaffold+Complete** pattern:

1. **Templates** create the deterministic scaffold — file structure, imports, wiring, and configuration that follows predictable patterns
2. **AI blocks** within those templates mark the spots that need intelligent decisions, providing context and constraints for each one
3. **A 2-pass execution** collects what the AI needs to decide, gets answers, then fills them in

This keeps the template author in control of structure while delegating judgment calls to an AI (or a human reviewer).

## How 2-Pass Generation Works

### Pass 1: Collect

When you run a recipe that contains `@ai` blocks and don't provide answers:

```bash
hypergen run ./my-recipe --name=User
```

Hypergen renders every template, but instead of writing files, it **collects** the AI blocks. Each block specifies:
- **Context**: What the AI needs to know (model fields, project conventions, etc.)
- **Prompt**: What to decide or generate
- **Output format**: An example of what the answer should look like

The result is a structured **prompt document** printed to stdout. Hypergen exits with code `2` to signal "Pass 1 complete, awaiting answers."

### Between Passes

The prompt document is a self-contained markdown file. You can:
- Pipe it to an AI tool: `hypergen run ./recipe --name=User | ai-tool > answers.json`
- Review and hand-edit the prompts or answers
- Feed it to any LLM via API and save the JSON response
- [Customize the prompt format](/guides/ai-integration/prompt-assembly#customizing-the-prompt-template) with your own Jig template via `--prompt-template` or the `ai.promptTemplate` config

### Pass 2: Resolve

Run the same recipe again with the answers:

```bash
hypergen run ./my-recipe --name=User --answers ./ai-answers.json
```

Now `@ai` blocks output the corresponding answer instead of collecting. Files are written normally.

## Visual Flow

```
┌─────────────────────────────────────────────────────┐
│  Pass 1                                             │
│                                                     │
│  recipe.yml ──► templates render ──► @ai blocks     │
│                   (no files written)    collected    │
│                                           │         │
│                                     prompt document │
│                                     (stdout, exit 2)│
└─────────────────────────────────────┬───────────────┘
                                      │
                              AI / human review
                                      │
                              ai-answers.json
                                      │
┌─────────────────────────────────────┴───────────────┐
│  Pass 2                                             │
│                                                     │
│  recipe.yml ──► templates render ──► @ai blocks     │
│   + answers       (files written)    resolved from  │
│                                      answers.json   │
└─────────────────────────────────────────────────────┘
```

## A Simple Example

Here's a template that asks AI to choose which fields to display on a card:

```edge
---
to: "src/components/{{ name }}Card.tsx"
---
import React from 'react';

interface {{ name }}CardProps {
  data: {{ name }};
}

export const {{ name }}Card: React.FC<{{ name }}CardProps> = ({ data }) => {
  return (
    <div className="card">
      @ai()
        @context()
          The {{ name }} model has these fields:
          {{ JSON.stringify(fields, null, 2) }}
        @end

        @prompt()
          Which fields are most relevant for a quick-view card?
          Return a JSX fragment showing each field in a <p> tag.
        @end

        @output({ key: 'cardFields' })
          <p>{data.name}</p>
          <p>{data.email}</p>
        @end
      @end
    </div>
  );
};
```

**Pass 1** renders the template context (interpolating `{{ name }}` and `{{ fields }}`) and collects the `cardFields` block. The output example (`<p>{data.name}</p>...`) serves as a format hint.

**Pass 2** replaces the entire `@ai` block with the answer from `ai-answers.json`:

```json
{
  "cardFields": "<p><strong>{data.name}</strong></p>\n<p>{data.email}</p>\n<p>{data.role}</p>"
}
```

## What's Next

- **[Custom Jig Tags Reference](/guides/ai-integration/jig-tags)** — Full reference for `@ai`, `@context`, `@prompt`, and `@output`
- **[Prompt Assembly](/guides/ai-integration/prompt-assembly)** — How the prompt document is structured
- **[Complete Example](/guides/ai-integration/example)** — End-to-end walkthrough with a real recipe
