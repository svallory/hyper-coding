---
title: Creating Your First Template
description: Build your first template and recipe from scratch
time: 20 minutes
prerequisites: Understanding of Hypergen concepts, text editor
---

<Note>
Hypergen now supports **automatic template processing**! All files in your `templates/` directory are automatically processed based on their extensions. No need to define explicit template steps in your recipe.
</Note>

# Creating Your First Template

**What you'll learn**: How to create a template, recipe, and test your first custom cookbook
**Time needed**: 20 minutes
**Prerequisites**: Understanding of Hypergen concepts, text editor

Let's build a simple cookbook that generates React components. This will teach you the fundamentals of template creation.

## Setup Your Cookbook Structure

Create the directory structure for your cookbook:

```bash
# Create cookbook directory
mkdir -p my-cookbook/react/component
cd my-cookbook/react/component

# Create the required subdirectories
mkdir templates actions
```

Your structure should look like:
```
my-cookbook/
└── react/
    └── component/
        ├── recipe.yml          # Recipe configuration (we'll create this)
        ├── templates/          # Template files
        └── actions/            # Action functions (optional)
```

## Create Your Recipe Configuration

Create `recipe.yml` with your recipe definition:

```yaml
# recipe.yml
name: component
description: Generate React component with TypeScript support
version: 1.0.0
author: your-name

variables:
  name:
    type: string
    required: true
    pattern: ^[A-Z][a-zA-Z0-9]*$
    description: Component name in PascalCase
    prompt: "What's your component name?"

  typescript:
    type: boolean
    default: true
    description: Generate TypeScript component
    prompt: "Include TypeScript?"

  includeTests:
    type: boolean
    default: true
    description: Generate test file
    prompt: "Include test file?"

  styling:
    type: enum
    values: [css, scss, styled-components, none]
    default: css
    description: Styling approach
    prompt: "Choose styling approach:"

# Templates are automatically processed from ./templates/
# No explicit steps needed for template generation!
# Files are processed based on extension:
# - .jig.t or .jig → Processed as Jig templates
# - .t.* → Processed with extension removed
# - Other files → Copied as-is

steps:
  # Optional: Add pre/post steps for complex workflows
  post:
    - name: Update index
      tool: action
      action: update-exports
```

### Understanding Automatic Template Processing

Hypergen automatically processes all files in your `templates/` directory. The file extension determines how each file is handled:

| Extension | Processing | Example |
|-----------|------------|---------|
| `.jig.t` | Jig template → removes `.jig.t` | `component.jig.t` → `component.tsx` |
| `.jig` | Jig template → removes `.jig` | `package.json.jig` → `package.json` |
| `.t.*` | Template → removes `.t` | `config.t.ts` → `config.ts` |
| No special extension | Copied as-is | `.gitignore` → `.gitignore` |

Templates can use YAML frontmatter to control their behavior:

```jig
---
to: src/components/{{ name }}.tsx
when: {{ includeTests }}
---
```

## Create Your First Template

Create `templates/component.jig` with the component template:

```jig
---
to: src/components/{{ name }}.{{ ternary :: typescript, "tsx", "jsx" }}
---
import React from 'react';
@if(styling == 'styled-components')
import styled from 'styled-components';
@elseif(styling == 'css' or styling == 'scss')
import styles from './{{ name }}.module.{{ styling }}';
@end

@if(typescript)
interface {{ name }}Props {
  children?: React.ReactNode;
  className?: string;
}

export const {{ name }}: React.FC<{{ name }}Props> = ({
  children,
  className
}) => {
@else
export const {{ name }} = ({ children, className }) => {
@end
  return (
    @if(styling == 'styled-components')
    <StyledWrapper className={className}>
      {children || 'Hello from {{ name }}!'}
    </StyledWrapper>
    @elseif(styling == 'css' or styling == 'scss')
    <div className={`${styles.{{ camelCase :: name }} ${className || ''}`}>
      {children || 'Hello from {{ name }}!'}
    </div>
    @else
    <div className={className}>
      {children || 'Hello from {{ name }}!'}
    </div>
    @end
  );
};

@if(styling == 'styled-components')
const StyledWrapper = styled.div`
  padding: 1rem;
  border: 1px solid #ddd;
  border-radius: 4px;

  &:hover {
    border-color: #007acc;
  }
`;
@end

export default {{ name }};
```

## Create the Styles Template

Create `templates/styles.jig` for CSS/SCSS files:

```jig
---
to: src/components/{{ name }}.module.{{ styling }}
when: {{ styling == 'css' or styling == 'scss' }}
---
@if(styling == 'scss')
$border-color: #ddd;
$hover-color: #007acc;
$padding: 1rem;

.{{ camelCase :: name }} {
  padding: $padding;
  border: 1px solid $border-color;
  border-radius: 4px;

  &:hover {
    border-color: $hover-color;
  }
}
@else
.{{ camelCase :: name }} {
  padding: 1rem;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.{{ camelCase :: name }}:hover {
  border-color: #007acc;
}
@end
```

## Create the Test Template

Create `templates/test.jig` for test files:

```jig
---
to: src/components/{{ name }}.test.{{ ternary :: typescript, "tsx", "jsx" }}
---
import React from 'react';
import { render, screen } from '@testing-library/react';
@if(typescript)
import '@testing-library/jest-dom';
@end
import {{ name }} from './{{ name }}';

describe('{{ name }}', () => {
  it('renders without crashing', () => {
    render(<{{ name }} />);
    expect(screen.getByText('Hello from {{ name }}!')).toBeInTheDocument();
  });

  it('renders children when provided', () => {
    render(<{{ name }}>Custom content</{{ name }}>);
    expect(screen.getByText('Custom content')).toBeInTheDocument();
  });

  it('applies className when provided', () => {
    render(<{{ name }} className="custom-class" />);
    const element = screen.getByText('Hello from {{ name }}!');
    expect(element.parentElement).toHaveClass('custom-class');
  });
});
```

## Create an Action (Optional)

Create `actions/update-exports.js` to update index files:

```javascript
// actions/update-exports.js
import { action } from 'hypergen/actions';
import type { ActionContext, ActionResult } from 'hypergen/types';
import fs from 'fs/promises';
import path from 'path';

async function updateExports(context: ActionContext): Promise<ActionResult> {
  const { args, utils, logger } = context;
  const indexPath = path.join(process.cwd(), 'src/components/index.ts');
  
  try {
    let content = '';
    
    // Read existing content if file exists
    try {
      content = await fs.readFile(indexPath, 'utf8');
    } catch (error) {
      // File doesn't exist, start with empty content
      content = '// Component exports\n';
    }
    
    // Check if export already exists
    const exportLine = `export { ${args.name} } from './${args.name}';`;
    if (!content.includes(exportLine)) {
      content += `${exportLine}\n`;
      
      // Write updated content
      await fs.writeFile(indexPath, content, 'utf8');
      logger.info(`✅ Added ${args.name} export to index.ts`);
    } else {
      logger.info(`ℹ️  Export for ${args.name} already exists`);
    }
    
    return { success: true };
  } catch (error) {
    logger.error(`❌ Failed to update exports: ${error.message}`);
    return { success: false, error: error.message };
  }
}

// Apply decorator
const decoratedAction = action({
  name: 'update-exports',
  description: 'Update component exports in index file',
  parameters: {
    name: { type: 'string', required: true }
  }
})(updateExports);

export { decoratedAction as updateExports };
```

## Test Your Recipe

### 1. Validate Configuration
```bash
# Validate your recipe.yml
hypergen recipe validate my-cookbook/react/component/recipe.yml
```

### 2. Dry Run
```bash
# See what would be generated
hypergen recipe execute my-cookbook/react/component/recipe.yml \
  --name="Button" \
  --dryRun
```

### 3. Execute Recipe
```bash
# Create a test directory
mkdir test-component && cd test-component

# Execute your recipe
hypergen recipe execute ../my-cookbook/react/component/recipe.yml \
  --name="Button" \
  --typescript=true \
  --includeTests=true \
  --styling="css"
```

**Success!** You should now have:
- `src/components/Button.tsx`
- `src/components/Button.module.css`  
- `src/components/Button.test.tsx`
- `src/components/index.ts` (created/updated)

## Understanding Template Features

### Frontmatter Options
Templates use YAML frontmatter for configuration:

```jig
---
to: src/{{ name }}.ts                    # Destination path
skip_if: {{ name == 'Skip' }}           # Skip condition
inject: true                            # Enable injection mode
inject_at_line: 10                      # Inject at specific line
unless_exists: true                     # Only if file doesn't exist
---
Template content here...
```

### Jig Filters
Hypergen provides many built-in filters:

```jig
{{ camelCase :: name }}        # Convert to camelCase
{{ pascalCase :: name }}       # Convert to PascalCase
{{ kebabCase :: name }}        # Convert to kebab-case
{{ snakeCase :: name }}        # Convert to snake_case
{{ humanize :: name }}         # Convert to human readable
{{ pluralize :: name }}        # Make plural
{{ singularize :: name }}      # Make singular
{{ ternary :: typescript, "tsx", "jsx" }}  # Conditional output
```

### Conditional Logic
Use Jig conditions and loops:

```jig
@if(typescript)
interface {{ name }}Props {
  // TypeScript interface
}
@end

@for(feature in features)
import {{ feature }} from './{{ feature }}';
@end

@unless(styling == 'none')
import styles from './styles.css';
@end
```

## Advanced Template Techniques

### Partial Templates
Break complex templates into reusable parts:

```jig
<!-- templates/partials/imports.jig -->
import React from 'react';
@if(typescript)import type { FC } from 'react';@end
@if(styling == 'styled-components')import styled from 'styled-components';@end
```

```jig
<!-- templates/component.jig -->
---
to: src/{{ name }}.tsx
---
@include('partials/imports.jig')

// Component implementation...
```

### Dynamic File Extensions
```jig
---
to: src/{{ name }}.{{ ternary :: typescript, "tsx", "jsx" }}
---
```

### Conditional File Creation
```jig
---
to: src/{{ name }}.test.{{ ternary :: typescript, "tsx", "jsx" }}
skip_if: {{ not includeTests }}
---
```

## Debugging Templates

### 1. Use Dry Run
```bash
hypergen recipe execute my-cookbook/react/component/recipe.yml \
  --name="Debug" \
  --dryRun \
  --verbose
```

### 2. Check Variable Values
Add debug output to templates:

```jig
<!-- Debug: name={{ name }}, typescript={{ typescript }} -->
```

### 3. Validate JSON in Variables
```bash
# Test complex variables
hypergen recipe execute my-cookbook/react/component/recipe.yml \
  --name="Test" \
  --config='{"debug": true, "port": 3000}' \
  --dryRun
```

## What's Next?

Now that you can create templates:

- **[Advanced Recipe Composition](/advanced-composition)** - Complex multi-step recipes
- **[TypeScript Actions](/tutorials/typescript-actions)** - Custom actions with TypeScript
- **[CodeMods and AST](/tutorials/codemods)** - Transform existing code

---

**Congratulations!** You've created your first cookbook with templates, recipes, and actions. This is the foundation for all advanced Hypergen development.