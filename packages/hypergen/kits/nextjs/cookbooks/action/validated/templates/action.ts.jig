---
to: "{{ dir }}/{{ name }}.ts"
---
'use server'

/**
 * {{ pascalCase(name) }} Server Action
 *
 * Handles form submission with Zod validation.
 * Provides field-level error handling and type-safe data extraction.
 * @if(withPrevState)
 * Can be used with useActionState hook for progressive enhancement.
 * @end
 */

import { {{ camelCase(name) }}Schema, type {{ pascalCase(name) }}Input } from '@/{{ schemaDir }}/{{ kebabCase(name) }}'
@if(returnPath)
import { redirect } from 'next/navigation'
import { revalidatePath } from 'next/cache'
@end

@if(withPrevState)
export type {{ pascalCase(name) }}State = {
  error?: string
  errors?: Record<string, string[]>
  success?: boolean
  data?: {{ pascalCase(name) }}Input
} | null

export async function {{ name }}(
  prevState: {{ pascalCase(name) }}State,
  formData: FormData
): Promise<{{ pascalCase(name) }}State> {
@else
export async function {{ name }}(formData: FormData) {
@end
  try {
    // Extract form data with type coercion
    const rawData = {
@each(field in fields)
@let(parts = field.split(':'))
@let(fieldName = parts[0])
@let(fieldType = parts[1] || 'string')
      {{ fieldName }}: @if(fieldType === 'number')
formData.get('{{ fieldName }}') ? Number(formData.get('{{ fieldName }}')) : undefined@elseif(fieldType === 'boolean')
formData.get('{{ fieldName }}') === 'true'@elseif(fieldType === 'date')
formData.get('{{ fieldName }}') ? new Date(formData.get('{{ fieldName }}') as string) : undefined@elseif(fieldType === 'array')
formData.getAll('{{ fieldName }}')@else
formData.get('{{ fieldName }}')@end
,
@endeach
    }

    // Validate with Zod schema
    const parsed = {{ camelCase(name) }}Schema.safeParse(rawData)

    if (!parsed.success) {
      const errors = parsed.error.flatten().fieldErrors
@if(withPrevState)
      return {
        error: 'Validation failed. Please check the form for errors.',
        errors,
      }
@else
      throw new Error('Validation failed: ' + JSON.stringify(errors))
@end
    }

    // Type-safe validated data
    const data = parsed.data

    // TODO: Implement your business logic here
    // The data is now fully validated and type-safe
    console.log('{{ pascalCase(name) }} validated data:', data)

    // Example: Save to database
    // await db.insert(users).values(data)

    // Example: Call external API
    // await fetch('/api/users', { method: 'POST', body: JSON.stringify(data) })

@if(returnPath)
    // Revalidate the path to show updated data
    revalidatePath('{{ returnPath }}')

    // Redirect to the specified path
    redirect('{{ returnPath }}')
@else
@if(withPrevState)
    return {
      success: true,
      data,
    }
@else
    return { success: true, data }
@end
@end
  } catch (error) {
    console.error('{{ pascalCase(name) }} error:', error)
@if(withPrevState)
    return {
      error: error instanceof Error ? error.message : 'An unexpected error occurred',
    }
@else
    throw error
@end
  }
}
