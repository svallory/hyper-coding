---
to: components/{{ model || pascalCase(name) }}Form.tsx
---
@let(modelName = model || pascalCase(name))
@let(modelVar = camelCase(model || pascalCase(name)))
@let(features = typeof detectProjectFeatures === 'function' ? detectProjectFeatures() : { orm: 'none' })
@let(modelFields = typeof parseFieldsString === 'function' && fields ? parseFieldsString(fields) : [])
@let(fieldDescriptions = typeof buildFieldDescriptions === 'function' ? buildFieldDescriptions(modelFields) : '')
'use client'

import { useRouter } from 'next/navigation'
import { useForm } from 'react-hook-form'
import { zodResolver } from '@hookform/resolvers/zod'
import { create{{ modelName }}, update{{ modelName }} } from '@/app/actions/{{ name }}'
import {
  {{ camelCase(modelName) }}Schema,
  type {{ modelName }},
} from '@/lib/schemas/{{ name }}-schema'
import { Button } from '@/components/ui/button'
import {
  Form,
  FormControl,
  FormField,
  FormItem,
  FormLabel,
  FormMessage,
} from '@/components/ui/form'
import { Input } from '@/components/ui/input'
import { Textarea } from '@/components/ui/textarea'
import { Switch } from '@/components/ui/switch'
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select'
import { useState } from 'react'
import { useToast } from '@/hooks/use-toast'

interface {{ modelName }}FormProps {
  initialData?: Partial<{{ modelName }}>
  id?: string
}

export function {{ modelName }}Form({ initialData, id }: {{ modelName }}FormProps) {
  const router = useRouter()
  const { toast } = useToast()
  const [isSubmitting, setIsSubmitting] = useState(false)

  const form = useForm<{{ modelName }}>({
    resolver: zodResolver({{ camelCase(modelName) }}Schema),
    defaultValues: initialData || {
@if(modelFields.length > 0)
@each(field in modelFields)
      {{ field.name }}: @if(field.type === 'boolean')false@elseif(field.type === 'number' || field.type === 'int' || field.type === 'float')0@elseif(field.type === 'date' || field.type === 'datetime')new Date()@else''@end,
@end
@else
      // Add default values for your fields
@end
    },
  })

  async function onSubmit(data: {{ modelName }}) {
    setIsSubmitting(true)

    try {
      if (id) {
        await update{{ modelName }}(id, data)
        toast({
          title: 'Success',
          description: '{{ modelName }} updated successfully',
        })
        router.push(`/{{ name }}/${id}`)
      } else {
        const result = await create{{ modelName }}(data)
        toast({
          title: 'Success',
          description: '{{ modelName }} created successfully',
        })
        router.push(`/{{ name }}/${result.id}`)
      }
      router.refresh()
    } catch (error) {
      toast({
        title: 'Error',
        description: error instanceof Error ? error.message : 'Something went wrong',
        variant: 'destructive',
      })
    } finally {
      setIsSubmitting(false)
    }
  }

  return (
    <Form {...form}>
      <form onSubmit={form.handleSubmit(onSubmit)} className="space-y-6">
        <div className="space-y-4">
@ai({ key: 'formFields' })
  @context()
Model: {{ modelName }}
Fields:
{{ fieldDescriptions }}
UI Library: shadcn/ui (React Hook Form integration)
Available components: FormField, FormItem, FormLabel, FormControl, FormMessage, Input, Textarea, Switch, Select, SelectContent, SelectItem, SelectTrigger, SelectValue
  @end
  @prompt()
Generate JSX form fields for the {{ modelName }} form using shadcn/ui components.
For each field, use the appropriate component:
- string → Input
- text → Textarea
- boolean → Switch (with flex layout)
- number/int/float → Input type="number" with onChange converting to Number
- date/datetime → Input type="datetime-local" with Date conversion
- email → Input type="email"
- Fields named "role" or "status" → Select with reasonable options
Each field should use the FormField/FormItem/FormLabel/FormControl/FormMessage pattern.
Required fields should show " *" after the label.
Output ONLY the JSX fragment — no wrapper divs, no imports.
  @end
  @output({ typeHint: 'jsx-fragment' })
JSX form fields using shadcn/ui FormField components, one per model field.
  @end
  @example()
          <FormField
            control={form.control}
            name="name"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Name *</FormLabel>
                <FormControl>
                  <Input placeholder="Enter name" {...field} />
                </FormControl>
                <FormMessage />
              </FormItem>
            )}
          />
          <FormField
            control={form.control}
            name="email"
            render={({ field }) => (
              <FormItem>
                <FormLabel>Email *</FormLabel>
                <FormControl>
                  <Input type="email" placeholder="Enter email" {...field} />
                </FormControl>
                <FormMessage />
              </FormItem>
            )}
          />
          <FormField
            control={form.control}
            name="isActive"
            render={({ field }) => (
              <FormItem className="flex flex-row items-center justify-between rounded-lg border p-4">
                <div className="space-y-0.5">
                  <FormLabel className="text-base">Is Active</FormLabel>
                </div>
                <FormControl>
                  <Switch checked={field.value} onCheckedChange={field.onChange} />
                </FormControl>
              </FormItem>
            )}
          />
  @end
@end
{{ formFields }}
        </div>

        <div className="flex gap-4">
          <Button type="submit" disabled={isSubmitting}>
            {isSubmitting ? 'Saving...' : id ? 'Update' : 'Create'}
          </Button>
          <Button
            type="button"
            variant="outline"
            onClick={() => router.back()}
            disabled={isSubmitting}
          >
            Cancel
          </Button>
        </div>
      </form>
    </Form>
  )
}
